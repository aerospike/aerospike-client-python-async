from typing import List, Optional

from typing_extensions import TypeAlias

class Client:
    async def hosts() -> str: ...

    async def close() -> None: ...

    # Write record bin(s). The policy specifies the transaction timeout, record expiration and
    # how the transaction is handled when the record already exists.
    async def put(key: Key, bins: dict[str, PythonValue], policy: Optional[WritePolicy]) -> None: ...

    # Read record for the specified key. Depending on the bins value provided, all record bins,
    # only selected record bins or only the record headers will be returned. The policy can be
    # used to specify timeouts.
    async def get(key: Key, bins: List[str] | None, policy: Optional[ReadPolicy]) -> Record: ...

    # Add integer bin values to existing record bin values. The policy specifies the transaction
    # timeout, record expiration and how the transaction is handled when the record already
    # exists. This call only works for integer values.
    async def add(key: Key, bins: dict[str, PythonValue], policy: Optional[WritePolicy]) -> None: ...

    # Append bin string values to existing record bin values. The policy specifies the
    # transaction timeout, record expiration and how the transaction is handled when the record
    # already exists. This call only works for string values.
    async def append(key: Key, bins: dict[str, PythonValue], policy: Optional[WritePolicy]) -> None: ...

    # Prepend bin string values to existing record bin values. The policy specifies the
    # transaction timeout, record expiration and how the transaction is handled when the record
    # already exists. This call only works for string values.
    async def prepend(key: Key, bins: dict[str, PythonValue], policy: Optional[WritePolicy]) -> None: ...

    # Delete record for specified key. The policy specifies the transaction timeout.
    # The call returns `true` if the record existed on the server before deletion.
    async def delete(key: Key, policy: Optional[WritePolicy]) -> bool: ...

    # Reset record's time to expiration using the policy's expiration. Fail if the record does
    # not exist.
    async def touch(key: Key, policy: Optional[WritePolicy]) -> None: ...

    # Determine if a record key exists. The policy can be used to specify timeouts.
    async def exists(key: Key, policy: Optional[WritePolicy]) -> bool: ...

    # Removes all records in the specified namespace/set efficiently.
    async def truncate(namespace: str, set_name: str, before_nanos: int | None) -> None: ...

    # Create a secondary index on a bin containing scalar values. This asynchronous server call
    # returns before the command is complete.
    async def create_index(namespace: str, set_name: str, bin_name: str, index_name: str, index_type: IndexType, cit: CollectionIndexType | None) -> None: ...

    async def drop_index(namespace: str, set_name: str, index_name: str) -> None: ...

    # Read all records in the specified namespace and set and return a record iterator. The scan
    # executor puts records on a queue in separate threads. The calling thread concurrently pops
    # records off the queue through the record iterator. Up to `policy.max_concurrent_nodes`
    # nodes are scanned in parallel. If concurrent nodes is set to zero, the server nodes are
    # read in series.
    async def scan(namespace: str, set_name: str, bins: list[str] | None, policy: Optional[ScanPolicy]) -> Recordset: ...

    # Execute a query on all server nodes and return a record iterator. The query executor puts
    # records on a queue in separate threads. The calling thread concurrently pops records off
    # the queue through the record iterator.
    async def query(statement: Statement, policy: Optional[QueryPolicy]) -> Recordset: ...

    # def __int__(self) -> _Int: ...
    # def __eq__(self, other: object) -> bool: ...
    # def __lt__(self, other: UUID) -> bool: ...
    # def __le__(self, other: UUID) -> bool: ...
    # def __gt__(self, other: UUID) -> bool: ...
    # def __ge__(self, other: UUID) -> bool: ...
    # def __getstate__(self) -> _Bytes: ...
    # def __setstate__(self, state: _Bytes) -> None: ...

async def new_client(hosts: str, policy: Optional[ClientPolicy]) -> Client: ...
