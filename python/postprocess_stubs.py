#!/usr/bin/env python3
"""
Post-process the generated .pyi stub files to fix issues that pyo3_stub_gen cannot handle automatically.

This consolidated script replaces multiple separate stub processing scripts and handles:
1. Exception classes: create_exception! macro doesn't generate stubs, so we manually add them
2. Policy classes: PyClassInitializer return types don't generate complete method stubs for
   ReadPolicy and WritePolicy, so we replace the placeholder with full method definitions
3. Import/export fixes: Ensures Key, Client, and Record are properly exported in __init__.pyi
4. Import cleanup: Fixes circular imports and uses relative imports where appropriate

All fixes are applied idempotently - safe to run multiple times.
"""

import os
import sys
import re


# Exception class stub definitions (defined once, reused everywhere)
EXCEPTION_STUB_CLASSES = '''class AerospikeError(builtins.Exception):
    """Base exception class for all Aerospike-specific errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ServerError(AerospikeError):
    """Exception raised when the Aerospike server returns an error."""
    def __init__(self, message: builtins.str, result_code: ResultCode) -> None: ...
    @property
    def result_code(self) -> ResultCode: ...

class UDFBadResponse(AerospikeError):
    """Exception raised when a UDF (User Defined Function) returns a bad response."""
    def __init__(self, message: builtins.str) -> None: ...

class TimeoutError(AerospikeError):
    """Exception raised when an operation times out."""
    def __init__(self, message: builtins.str) -> None: ...

class Base64DecodeError(AerospikeError):
    """Exception raised when Base64 decoding fails."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidUTF8(AerospikeError):
    """Exception raised when invalid UTF-8 is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class IoError(AerospikeError):
    """Exception raised for I/O related errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseAddressError(AerospikeError):
    """Exception raised when parsing an address fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseIntError(AerospikeError):
    """Exception raised when parsing an integer fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ConnectionError(AerospikeError):
    """Exception raised when a connection error occurs."""
    def __init__(self, message: builtins.str) -> None: ...

class ValueError(AerospikeError):
    """Exception raised when an invalid value is provided."""
    def __init__(self, message: builtins.str) -> None: ...

class RecvError(AerospikeError):
    """Exception raised when receiving data fails."""
    def __init__(self, message: builtins.str) -> None: ...

class PasswordHashError(AerospikeError):
    """Exception raised when password hashing fails."""
    def __init__(self, message: builtins.str) -> None: ...

class BadResponse(AerospikeError):
    """Exception raised when a bad response is received."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidRustClientArgs(AerospikeError):
    """Exception raised when invalid arguments are provided to the Rust client."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidNodeError(AerospikeError):
    """Exception raised when an invalid node is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class NoMoreConnections(AerospikeError):
    """Exception raised when no more connections are available."""
    def __init__(self, message: builtins.str) -> None: ...

class ClientError(AerospikeError):
    """Exception raised for client-side errors."""
    def __init__(self, message: builtins.str) -> None: ...
'''

EXCEPTION_STUB__ALL__ = '''
__all__ = [
    "AerospikeError",
    "ServerError",
    "UDFBadResponse",
    "TimeoutError",
    "BadResponse",
    "ConnectionError",
    "InvalidNodeError",
    "NoMoreConnections",
    "RecvError",
    "Base64DecodeError",
    "InvalidUTF8",
    "ParseAddressError",
    "ParseIntError",
    "ValueError",
    "IoError",
    "PasswordHashError",
    "InvalidRustClientArgs",
    "ClientError",
    "ResultCode",
]
'''

EXCEPTIONS_SUBMODULE_STUB = f'''# This file contains type stubs for the aerospike_async.exceptions submodule
# Generated by postprocess_stubs.py

import builtins
from .._aerospike_async_native import ResultCode

# Exception classes
{EXCEPTION_STUB_CLASSES}

# ResultCode is re-exported from the main module for convenience
# It's defined in _aerospike_async_native and added to exceptions submodule at runtime
{EXCEPTION_STUB__ALL__}'''


def fix_imports(content: str, pyi_file_path: str = "") -> str:
    """Fix import statements to use relative imports and avoid circular dependencies."""
    # Fix absolute imports from aerospike_async._aerospike_async_native to relative imports
    content = re.sub(
        r'from aerospike_async\._aerospike_async_native import ([\w, ]+)',
        r'from ._aerospike_async_native import \1',
        content
    )
    # Fix any existing circular imports
    content = re.sub(
        r'^from aerospike_async import (Key|Record|Blob|GeoJSON|HLL|List|Map|Client)\b',
        r'from ._aerospike_async_native import \1',
        content,
        flags=re.MULTILINE
    )

    # Remove self-imports in _aerospike_async_native.pyi - types are now all in the same module
    if '_aerospike_async_native.pyi' in pyi_file_path:
        content = re.sub(
            r'^from _aerospike_async_native import [^\n]+\n',
            '',
            content,
            flags=re.MULTILINE
        )

    return content


def ensure_exports(content: str) -> str:
    """Ensure all classes are properly imported from _aerospike_async_native in __init__.pyi.

    The runtime __init__.py uses 'from ._aerospike_async_native import *', so the stub
    should match this for consistency. We also explicitly re-export Key, Client, and Record
    for better type checker support.
    """
    # Use 'import *' to match runtime behavior - all classes are available
    if 'from ._aerospike_async_native import *' not in content:
        # Replace any existing specific imports with wildcard import
        content = re.sub(
            r'from \._aerospike_async_native import [^\n]+\n',
            'from ._aerospike_async_native import *\n',
            content
        )
        # Or add it if no import exists
        if 'from ._aerospike_async_native' not in content:
            if 'import builtins' in content:
                content = re.sub(
                    r'(import builtins\n)',
                    r'\1from ._aerospike_async_native import *\n',
                    content
                )
            else:
                # Add at the beginning after any existing imports
                content = 'from ._aerospike_async_native import *\n' + content

    # Explicitly re-export commonly used classes for type checker clarity
    # Some type checkers don't fully resolve 'import *', so explicit re-exports help
    needed_exports = ['Key', 'Client', 'Record', 'ReadPolicy', 'WritePolicy', 'FilterExpression', 'BasePolicy']
    missing_exports = []
    for export in needed_exports:
        if not re.search(rf'^{export}\s*:\s*type\s*=\s*_aerospike_async_native\.{export}\b', content, re.MULTILINE):
            missing_exports.append(export)

    if missing_exports:
        class_match = re.search(r'^(class\s+\w+)', content, re.MULTILINE)
        if class_match:
            insert_pos = class_match.start()
            # Build re-exports - keep existing ones, add missing ones
            existing_lines = []
            new_lines = []
            for export in needed_exports:
                if export not in missing_exports:
                    # Extract existing line
                    existing_match = re.search(rf'^{export}\s*:\s*type\s*=\s*_aerospike_async_native\.{export}\b', content, re.MULTILINE)
                    if existing_match:
                        existing_lines.append((existing_match.start(), existing_match.end()))
                else:
                    new_lines.append(f'{export}: type = _aerospike_async_native.{export}')

            # Remove existing re-export section if it exists, then add complete one
            re_export_match = re.search(r'^# (Re-export|Explicit re-exports)', content, re.MULTILINE)
            if re_export_match:
                # Find the end of the re-export section (before next class or blank line)
                section_start = re_export_match.start()
                next_section = re.search(r'\n\n(?=class\s|\n#)', content[section_start:], re.MULTILINE)
                if next_section:
                    section_end = section_start + next_section.start() + 1
                    content = content[:section_start] + content[section_end:]
                    # Re-find class position after removal
                    class_match = re.search(r'^(class\s+\w+)', content, re.MULTILINE)
                    if class_match:
                        insert_pos = class_match.start()

            # Add all re-exports (both existing and new)
            all_exports = [f'{exp}: type = _aerospike_async_native.{exp}' for exp in needed_exports]
            re_exports = '# Explicit re-exports for type checking\n' + '\n'.join(all_exports) + '\n\n'
            content = content[:insert_pos] + re_exports + content[insert_pos:]

    return content


def add_client_stubs(content: str) -> str:
    """Add Client class stubs if missing (pyo3_stub_gen doesn't generate it when only referenced in override_return_type)."""
    client_stub = '''class Client:
    r"""
    Aerospike async client for database operations.
    Create instances using new_client() function.
    """
    def seeds(self) -> builtins.str: ...
    def close(self) -> typing.Awaitable[typing.Any]: ...
    def is_connected(self) -> typing.Awaitable[builtins.bool]: ...
    def put(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def get(self, policy: ReadPolicy, key: Key, bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Any]: ...
    def add(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def append(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def prepend(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def delete(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def touch(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists_legacy(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Tuple[Key, typing.Optional[typing.Any]]]: ...
    def truncate(self, namespace: builtins.str, set_name: builtins.str, before_nanos: typing.Optional[builtins.int] = None) -> typing.Awaitable[typing.Any]: ...
    def create_index(self, namespace: builtins.str, set_name: builtins.str, bin_name: builtins.str, index_name: builtins.str, index_type: IndexType, cit: typing.Optional[CollectionIndexType] = None) -> typing.Awaitable[typing.Any]: ...
    def drop_index(self, namespace: builtins.str, set_name: builtins.str, index_name: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def query(self, policy: QueryPolicy, partition_filter: PartitionFilter, statement: Statement) -> typing.Awaitable[typing.Any]: ...
    def operate(self, policy: WritePolicy, key: Key, operations: typing.Sequence[typing.Union[Operation, ListOperation, MapOperation, BitOperation]]) -> typing.Awaitable[Record]: ...
    def batch_read(self, batch_policy: typing.Optional[BatchPolicy], read_policy: typing.Optional[BatchReadPolicy], keys: typing.Sequence[Key], bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_write(self, batch_policy: typing.Optional[BatchPolicy], write_policy: typing.Optional[BatchWritePolicy], keys: typing.Sequence[Key], bins_list: typing.Sequence[typing.Dict[builtins.str, typing.Any]]) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_operate(self, batch_policy: typing.Optional[BatchPolicy], write_policy: typing.Optional[BatchWritePolicy], keys: typing.Sequence[Key], operations_list: typing.Sequence[typing.Sequence[typing.Union[Operation, ListOperation, MapOperation, BitOperation]]]) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_delete(self, batch_policy: typing.Optional[BatchPolicy], delete_policy: typing.Optional[BatchDeletePolicy], keys: typing.Sequence[Key]) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_apply(self, batch_policy: typing.Optional[BatchPolicy], udf_policy: typing.Optional[BatchUDFPolicy], keys: typing.Sequence[Key], udf_name: builtins.str, function_name: builtins.str, args: typing.Optional[typing.Sequence[typing.Any]] = None) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_exists(self, batch_policy: typing.Optional[BatchPolicy], read_policy: typing.Optional[BatchReadPolicy], keys: typing.Sequence[Key]) -> typing.Awaitable[typing.Sequence[builtins.bool]]: ...
    def batch_get_header(self, batch_policy: typing.Optional[BatchPolicy], read_policy: typing.Optional[BatchReadPolicy], keys: typing.Sequence[Key]) -> typing.Awaitable[typing.Sequence[typing.Optional[Record]]]: ...
    def create_user(self, user: builtins.str, password: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def create_pki_user(self, user: builtins.str, roles: typing.Sequence[builtins.str], *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[typing.Any]: ...
    def drop_user(self, user: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def change_password(self, user: builtins.str, password: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def grant_roles(self, user: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def revoke_roles(self, user: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def query_users(self, user: typing.Optional[builtins.str] = None) -> typing.Awaitable[typing.Sequence[User]]: ...
    def query_roles(self, role: typing.Optional[builtins.str] = None) -> typing.Awaitable[typing.Sequence[Role]]: ...
    def create_role(self, role_name: builtins.str, privileges: typing.Sequence[Privilege], allowlist: typing.Sequence[builtins.str], read_quota: builtins.int, write_quota: builtins.int) -> typing.Awaitable[typing.Any]: ...
    def drop_role(self, role_name: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def grant_privileges(self, role_name: builtins.str, privileges: typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]: ...
    def revoke_privileges(self, role_name: builtins.str, privileges: typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]: ...
    def set_allowlist(self, role_name: builtins.str, allowlist: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def set_quotas(self, role_name: builtins.str, read_quota: builtins.int, write_quota: builtins.int) -> typing.Awaitable[typing.Any]: ...
'''

    # Check if Client class is missing
    if 'class Client:' not in content:
        # Insert before new_client function
        new_client_match = re.search(r'^def new_client\(', content, re.MULTILINE)
        if new_client_match:
            insert_pos = new_client_match.start()
            content = content[:insert_pos] + client_stub + '\n' + content[insert_pos:]
            print("  ✓ Added Client class stubs (pyo3_stub_gen limitation)")
        else:
            # Insert at the end if new_client not found
            content = content + '\n' + client_stub
            print("  ✓ Added Client class stubs (at end)")
    else:
        # Client class exists - check if security methods are missing and add them
        security_methods = [
            'create_pki_user', 'change_password', 'grant_roles', 'revoke_roles', 'query_users', 'query_roles',
            'create_role', 'drop_role', 'grant_privileges', 'revoke_privileges',
            'set_allowlist', 'set_quotas'
        ]
        missing_methods = []
        for method in security_methods:
            if not re.search(rf'^\s+def {method}\(', content, re.MULTILINE):
                missing_methods.append(method)

        if missing_methods:
            # Find the end of the Client class (before the next class or function)
            client_match = re.search(r'^class Client:', content, re.MULTILINE)
            if client_match:
                # Find the end of the class (next class, function, or end of file)
                class_start = client_match.start()
                next_class = re.search(r'\n\n(?=class\s|\ndef\s)', content[class_start:], re.MULTILINE)
                if next_class:
                    insert_pos = class_start + next_class.start() + 1
                else:
                    # Insert before new_client if it exists
                    new_client_match = re.search(r'^def new_client\(', content[class_start:], re.MULTILINE)
                    if new_client_match:
                        insert_pos = class_start + new_client_match.start()
                    else:
                        insert_pos = len(content)

                # Extract just the missing method stubs
                method_stubs = []
                for method in missing_methods:
                    if method == 'change_password':
                        method_stubs.append('    def change_password(self, user: builtins.str, password: builtins.str) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'grant_roles':
                        method_stubs.append('    def grant_roles(self, user: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'revoke_roles':
                        method_stubs.append('    def revoke_roles(self, user: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'query_users':
                        method_stubs.append('    def query_users(self, user: typing.Optional[builtins.str] = None) -> typing.Awaitable[typing.Sequence[User]]: ...')
                    elif method == 'query_roles':
                        method_stubs.append('    def query_roles(self, role: typing.Optional[builtins.str] = None) -> typing.Awaitable[typing.Sequence[Role]]: ...')
                    elif method == 'create_role':
                        method_stubs.append('    def create_role(self, role_name: builtins.str, privileges: typing.Sequence[Privilege], allowlist: typing.Sequence[builtins.str], read_quota: builtins.int, write_quota: builtins.int) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'drop_role':
                        method_stubs.append('    def drop_role(self, role_name: builtins.str) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'grant_privileges':
                        method_stubs.append('    def grant_privileges(self, role_name: builtins.str, privileges: typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'revoke_privileges':
                        method_stubs.append('    def revoke_privileges(self, role_name: builtins.str, privileges: typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'set_allowlist':
                        method_stubs.append('    def set_allowlist(self, role_name: builtins.str, allowlist: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...')
                    elif method == 'set_quotas':
                        method_stubs.append('    def set_quotas(self, role_name: builtins.str, read_quota: builtins.int, write_quota: builtins.int) -> typing.Awaitable[typing.Any]: ...')

                # Insert methods before the closing of the class or before new_client
                methods_to_add = '\n' + '\n'.join(method_stubs) + '\n'
                content = content[:insert_pos] + methods_to_add + content[insert_pos:]
                print(f"  ✓ Added missing security methods to Client class: {', '.join(missing_methods)}")

    return content


def add_batch_policy_stubs(content: str) -> str:
    """Add missing properties to BatchPolicy class."""
    batch_policy_properties = '''    @property
    def allow_inline(self) -> builtins.bool: ...
    @allow_inline.setter
    def allow_inline(self, value: builtins.bool) -> None: ...
    @property
    def allow_inline_ssd(self) -> builtins.bool: ...
    @allow_inline_ssd.setter
    def allow_inline_ssd(self, value: builtins.bool) -> None: ...
    @property
    def respond_all_keys(self) -> builtins.bool: ...
    @respond_all_keys.setter
    def respond_all_keys(self, value: builtins.bool) -> None: ...
'''

    # Check if BatchPolicy class exists and add properties if missing
    batch_policy_match = re.search(r'^class BatchPolicy\(BasePolicy\):', content, re.MULTILINE)
    if batch_policy_match:
        # Find the end of the class (next class or blank line)
        class_start = batch_policy_match.start()
        next_class = re.search(r'\n\n(?=class\s|\ndef\s)', content[class_start:], re.MULTILINE)
        if next_class:
            insert_pos = class_start + next_class.start() + 1
        else:
            # Find the next class or function
            next_match = re.search(r'\n(?=class\s|\ndef\s)', content[class_start:], re.MULTILINE)
            if next_match:
                insert_pos = class_start + next_match.start() + 1
            else:
                insert_pos = len(content)

        # Check if properties already exist
        if '@property\n    def allow_inline(self)' not in content:
            content = content[:insert_pos] + batch_policy_properties + content[insert_pos:]
            print("  ✓ Added missing properties to BatchPolicy class")

    return content


def add_record_stubs(content: str) -> str:
    """Add Record class stubs if missing (pyo3_stub_gen limitation)."""
    record_stub = '''class Record:
    r"""
    Aerospike record returned from get() and operate() operations.
    """
    def bin(self, name: builtins.str) -> typing.Optional[typing.Any]: ...
    @property
    def bins(self) -> typing.Dict[builtins.str, typing.Any]: ...
    @property
    def generation(self) -> typing.Optional[builtins.int]: ...
    @property
    def ttl(self) -> typing.Optional[builtins.int]: ...
    @property
    def key(self) -> typing.Optional[Key]: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
'''

    # Check if Record class is missing
    if 'class Record:' not in content:
        # Insert before Client class if it exists, otherwise before new_client function
        client_match = re.search(r'^class Client:', content, re.MULTILINE)
        if client_match:
            insert_pos = client_match.start()
            content = content[:insert_pos] + record_stub + '\n' + content[insert_pos:]
            print("  ✓ Added Record class stubs (pyo3_stub_gen limitation)")
        else:
            # Insert before new_client function
            new_client_match = re.search(r'^def new_client\(', content, re.MULTILINE)
            if new_client_match:
                insert_pos = new_client_match.start()
                content = content[:insert_pos] + record_stub + '\n' + content[insert_pos:]
                print("  ✓ Added Record class stubs (pyo3_stub_gen limitation)")
            else:
                # Insert at the end if nothing found
                content = content + '\n' + record_stub
                print("  ✓ Added Record class stubs (at end)")

    return content


def add_key_stubs(content: str) -> str:
    """Add Key class stubs if missing (pyo3_stub_gen limitation)."""
    key_stub = '''class Key:
    r"""
    Aerospike record key. Create keys using Key(namespace, set, key) or Key.key_with_digest().
    """
    def __new__(cls, namespace: builtins.str, set: builtins.str, key: typing.Any) -> Key: ...
    @property
    def namespace(self) -> builtins.str: ...
    @property
    def set_name(self) -> builtins.str: ...
    @property
    def value(self) -> typing.Optional[typing.Any]: ...
    @property
    def digest(self) -> typing.Optional[builtins.str]: ...
    @staticmethod
    def key_with_digest(namespace: builtins.str, set: builtins.str, digest: typing.Union[builtins.bytes, builtins.str]) -> Key: ...
'''

    # Check if Key class is missing
    if 'class Key:' not in content:
        # Insert before Operation classes if they exist
        operation_match = re.search(r'^class Operation:', content, re.MULTILINE)
        if operation_match:
            insert_pos = operation_match.start()
            content = content[:insert_pos] + key_stub + '\n' + content[insert_pos:]
            print("  ✓ Added Key class stubs (pyo3_stub_gen limitation)")
        else:
            # Insert before Client class if it exists
            client_match = re.search(r'^class Client:', content, re.MULTILINE)
            if client_match:
                insert_pos = client_match.start()
                content = content[:insert_pos] + key_stub + '\n' + content[insert_pos:]
                print("  ✓ Added Key class stubs (pyo3_stub_gen limitation)")
            else:
                # Insert before new_client function
                new_client_match = re.search(r'^def new_client\(', content, re.MULTILINE)
                if new_client_match:
                    insert_pos = new_client_match.start()
                    content = content[:insert_pos] + key_stub + '\n' + content[insert_pos:]
                    print("  ✓ Added Key class stubs (pyo3_stub_gen limitation)")
                else:
                    # Insert at the end if nothing found
                    content = content + '\n' + key_stub
                    print("  ✓ Added Key class stubs (at end)")

    return content


def add_operation_stubs(content: str) -> str:
    """Add Operation class stubs if missing (pyo3_stub_gen limitation)."""
    # Operation classes are large with many static methods, so we add minimal stubs
    # that indicate the classes exist. The actual methods are available at runtime.
    operation_stubs = '''class Operation:
    r"""
    Basic bin operations. Create operations used by the client's operate() method.
    """
    def __new__(cls) -> Operation: ...
    @staticmethod
    def new() -> Operation: ...
    @staticmethod
    def get() -> Operation: ...
    @staticmethod
    def get_bin(bin_name: builtins.str) -> Operation: ...
    @staticmethod
    def put(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    @staticmethod
    def get_header() -> Operation: ...
    @staticmethod
    def delete() -> Operation: ...
    @staticmethod
    def touch() -> Operation: ...
    @staticmethod
    def add(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    @staticmethod
    def append(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    @staticmethod
    def prepend(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    def set_context(self, ctx: typing.Sequence[CTX]) -> Operation: ...

class ListOperation:
    r"""
    List bin operations. Create list operations used by the client's operate() method.
    """
    def __new__(cls) -> ListOperation: ...
    def set_context(self, ctx: typing.Sequence[CTX]) -> ListOperation: ...
    @staticmethod
    def get(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def size(bin_name: builtins.str) -> ListOperation: ...
    @staticmethod
    def pop(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def clear(bin_name: builtins.str) -> ListOperation: ...
    @staticmethod
    def get_range(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def set(bin_name: builtins.str, index: builtins.int, value: typing.Any) -> ListOperation: ...
    @staticmethod
    def remove(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def remove_range(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def get_range_from(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def pop_range(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def pop_range_from(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def remove_range_from(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def trim(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def append(bin_name: builtins.str, value: typing.Any, policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def append_items(bin_name: builtins.str, values: typing.Sequence[typing.Any], policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def insert(bin_name: builtins.str, index: builtins.int, value: typing.Any, policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def insert_items(bin_name: builtins.str, index: builtins.int, values: typing.Sequence[typing.Any], policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def increment(bin_name: builtins.str, index: builtins.int, value: builtins.int, policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def sort(bin_name: builtins.str, flags: ListSortFlags) -> ListOperation: ...
    @staticmethod
    def set_order(bin_name: builtins.str, order: ListOrderType) -> ListOperation: ...
    @staticmethod
    def get_by_index(bin_name: builtins.str, index: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_index_range(bin_name: builtins.str, index: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value(bin_name: builtins.str, value: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_index(bin_name: builtins.str, index: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_index_range(bin_name: builtins.str, index: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value(bin_name: builtins.str, value: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def create(bin_name: builtins.str, order: ListOrderType, pad: builtins.bool, persist_index: builtins.bool) -> ListOperation: ...

class MapOperation:
    r"""
    Map bin operations. Create map operations used by the client's operate() method.
    """
    def __new__(cls) -> MapOperation: ...
    def set_context(self, ctx: typing.Sequence[CTX]) -> MapOperation: ...
    @staticmethod
    def size(bin_name: builtins.str) -> MapOperation: ...
    @staticmethod
    def clear(bin_name: builtins.str) -> MapOperation: ...
    @staticmethod
    def put(bin_name: builtins.str, key: typing.Any, value: typing.Any, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def put_items(bin_name: builtins.str, items: typing.Sequence[typing.Tuple[typing.Any, typing.Any]], policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def increment_value(bin_name: builtins.str, key: typing.Any, value: builtins.int, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def decrement_value(bin_name: builtins.str, key: typing.Any, value: builtins.int, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def get_by_key(bin_name: builtins.str, key: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key(bin_name: builtins.str, key: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_key_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_index(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_index(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_index_range(bin_name: builtins.str, index: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_index_range(bin_name: builtins.str, index: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_index_range_from(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_index_range_from(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_rank_range_from(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_rank_range_from(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value(bin_name: builtins.str, value: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value(bin_name: builtins.str, value: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_key_list(bin_name: builtins.str, keys: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key_list(bin_name: builtins.str, keys: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def set_map_policy(bin_name: builtins.str, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def get_by_key_relative_index_range(bin_name: builtins.str, key: typing.Any, index: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key_relative_index_range(bin_name: builtins.str, key: typing.Any, index: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def create(bin_name: builtins.str, order: MapOrder) -> MapOperation: ...

class BitOperation:
    r"""
    Bit operations. Create bit operations used by the client's operate() method.
    """
    def __new__(cls) -> BitOperation: ...
    def set_context(self, ctx: typing.Sequence[CTX]) -> BitOperation: ...
    @staticmethod
    def resize(bin_name: builtins.str, byte_size: builtins.int, resize_flags: typing.Optional[BitwiseResizeFlags], policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def insert(bin_name: builtins.str, byte_offset: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def remove(bin_name: builtins.str, byte_offset: builtins.int, byte_size: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def set(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def or(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def xor(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def and(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def not(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def lshift(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, shift: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def rshift(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, shift: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def add(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.int, signed: builtins.bool, action: BitwiseOverflowActions, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def subtract(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.int, signed: builtins.bool, action: BitwiseOverflowActions, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def set_int(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def get(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int) -> BitOperation: ...
    @staticmethod
    def count(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int) -> BitOperation: ...
    @staticmethod
    def lscan(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.bool) -> BitOperation: ...
    @staticmethod
    def rscan(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.bool) -> BitOperation: ...
    @staticmethod
    def get_int(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, signed: builtins.bool) -> BitOperation: ...
'''

    # Check if Operation classes are missing
    if 'class Operation:' not in content:
        # Insert before Client class if it exists, otherwise before new_client function
        client_match = re.search(r'^class Client:', content, re.MULTILINE)
        if client_match:
            insert_pos = client_match.start()
            content = content[:insert_pos] + operation_stubs + '\n' + content[insert_pos:]
            print("  ✓ Added Operation class stubs (pyo3_stub_gen limitation)")
        else:
            # Insert before new_client function
            new_client_match = re.search(r'^def new_client\(', content, re.MULTILINE)
            if new_client_match:
                insert_pos = new_client_match.start()
                content = content[:insert_pos] + operation_stubs + '\n' + content[insert_pos:]
                print("  ✓ Added Operation class stubs (pyo3_stub_gen limitation)")
            else:
                # Insert at the end if neither found
                content = content + '\n' + operation_stubs
                print("  ✓ Added Operation class stubs (at end)")

    return content


# Note: PartitionFilter and PartitionStatus stubs are generated automatically by pyo3_stub_gen
# No postprocessing needed for these classes


def ensure_statement_set_name(content: str) -> str:
    """Ensure Statement class has set_name property with correct type annotations."""
    # Only fix Statement.__new__ signature - other methods (truncate, create_index, etc.) require set_name
    # Ensure __new__ signature uses typing.Optional[str] = None for Statement
    content = re.sub(
        r'def __new__\(cls, namespace:builtins\.str, set_name:([^,)]+), bins:',
        r'def __new__(cls, namespace:builtins.str, set_name:typing.Optional[str] = None, bins:',
        content
    )

    # Fix property to use str instead of builtins.str for PyCharm
    content = re.sub(
        r'@property\s+def set_name\(self\) -> typing\.Optional\[builtins\.str\]:',
        '@property\n    def set_name(self) -> typing.Optional[str]:',
        content
    )
    content = re.sub(
        r'@set_name\.setter\s+def set_name\(self, value: typing\.Optional\[builtins\.str\]\) -> None:',
        '@set_name.setter\n    def set_name(self, value: typing.Optional[str]) -> None:',
        content
    )

    # Check if set_name property already exists
    if '@property\n    def set_name(self) -> typing.Optional[str]:' in content:
        return content

    # Find Statement class and insert set_name after filters property
    filters_setter_match = re.search(
        r'@filters\.setter\s+def filters\(self, value: typing\.Optional\[builtins\.list\[Filter\]\]\) -> None: \.\.\.',
        content,
        re.MULTILINE
    )
    if filters_setter_match:
        insert_pos = filters_setter_match.end()
        set_name_stub = '\n    @property\n    def set_name(self) -> typing.Optional[str]: ...\n    @set_name.setter\n    def set_name(self, value: typing.Optional[str]) -> None: ...'
        content = content[:insert_pos] + set_name_stub + content[insert_pos:]
        print("  ✓ Added set_name property to Statement class")

    return content


def add_policy_stubs(content: str) -> str:
    """Add full method stubs for WritePolicy, ReadPolicy, and QueryPolicy classes."""
    read_policy_stub = '''class ReadPolicy(BasePolicy):
    def __new__(cls) -> ReadPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
'''

    write_policy_stub = '''class WritePolicy(BasePolicy):
    def __new__(cls) -> WritePolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def record_exists_action(self) -> RecordExistsAction: ...
    @record_exists_action.setter
    def record_exists_action(self, value: RecordExistsAction) -> None: ...
    @property
    def generation_policy(self) -> GenerationPolicy: ...
    @generation_policy.setter
    def generation_policy(self, value: GenerationPolicy) -> None: ...
    @property
    def commit_level(self) -> CommitLevel: ...
    @commit_level.setter
    def commit_level(self, value: CommitLevel) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
'''

    query_policy_stub = '''class QueryPolicy(BasePolicy):
    def __new__(cls) -> QueryPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def records_per_second(self) -> builtins.int: ...
    @records_per_second.setter
    def records_per_second(self, value: builtins.int) -> None: ...
    @property
    def max_records(self) -> builtins.int: ...
    @max_records.setter
    def max_records(self, value: builtins.int) -> None: ...
    @property
    def expected_duration(self) -> QueryDuration: ...
    @expected_duration.setter
    def expected_duration(self, value: QueryDuration) -> None: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
'''

    patterns = [
        (r'class ReadPolicy\(BasePolicy\):\s*\.\.\.', read_policy_stub, "ReadPolicy"),
        (r'class WritePolicy\(BasePolicy\):\s*\.\.\.', write_policy_stub, "WritePolicy"),
        (r'class QueryPolicy\(BasePolicy\):\s*\.\.\.', query_policy_stub, "QueryPolicy"),
    ]

    for pattern, stub, name in patterns:
        if re.search(pattern, content):
            content = re.sub(pattern, stub.rstrip(), content)
            print(f"  ✓ Updated {name} class stubs")

    return content


def ensure_exceptions_submodule(package_dir: str):
    """Always regenerate the exceptions submodule stub file and runtime __init__.py."""
    exceptions_dir = os.path.join(package_dir, 'exceptions')
    os.makedirs(exceptions_dir, exist_ok=True)

    # Always write stub file for type checking (regenerate every time)
    init_stub_path = os.path.join(exceptions_dir, '__init__.pyi')
    with open(init_stub_path, 'w') as f:
        f.write(EXCEPTIONS_SUBMODULE_STUB)
    print(f"  ✓ Regenerated exceptions submodule stub: {init_stub_path}")

    # Always write runtime __init__.py (regenerate every time)
    # PyO3's create_exception! creates exceptions in aerospike_async.exceptions
    # The exceptions submodule is created by PyO3 when we call add_submodule
    # We need to access it from the parent package
    init_py_path = os.path.join(exceptions_dir, '__init__.py')
    with open(init_py_path, 'w') as f:
        f.write('# Exceptions are created by PyO3 in this submodule\n')
        f.write('# via create_exception!(aerospike_async.exceptions, ...) and add_submodule\n')
        f.write('# Users can import: from aerospike_async.exceptions import AerospikeError\n')
        f.write('\n')
        f.write('import sys\n')
        f.write('from .. import _aerospike_async_native\n')
        f.write('\n')
        f.write('# Access the exceptions submodule created by PyO3\n')
        f.write('_exceptions = getattr(_aerospike_async_native, "exceptions", None)\n')
        f.write('if _exceptions is None:\n')
        f.write('    raise ImportError("Exceptions submodule not found in native module")\n')
        f.write('\n')
        f.write('# Re-export all exception classes\n')
        f.write('AerospikeError = _exceptions.AerospikeError\n')
        f.write('ServerError = _exceptions.ServerError\n')
        f.write('UDFBadResponse = _exceptions.UDFBadResponse\n')
        f.write('TimeoutError = _exceptions.TimeoutError\n')
        f.write('BadResponse = _exceptions.BadResponse\n')
        f.write('ConnectionError = _exceptions.ConnectionError\n')
        f.write('InvalidNodeError = _exceptions.InvalidNodeError\n')
        f.write('NoMoreConnections = _exceptions.NoMoreConnections\n')
        f.write('RecvError = _exceptions.RecvError\n')
        f.write('Base64DecodeError = _exceptions.Base64DecodeError\n')
        f.write('InvalidUTF8 = _exceptions.InvalidUTF8\n')
        f.write('ParseAddressError = _exceptions.ParseAddressError\n')
        f.write('ParseIntError = _exceptions.ParseIntError\n')
        f.write('ValueError = _exceptions.ValueError\n')
        f.write('IoError = _exceptions.IoError\n')
        f.write('PasswordHashError = _exceptions.PasswordHashError\n')
        f.write('InvalidRustClientArgs = _exceptions.InvalidRustClientArgs\n')
        f.write('ClientError = _exceptions.ClientError\n')
        f.write('# ResultCode is in the main native module, not in exceptions submodule\n')
        f.write('ResultCode = _aerospike_async_native.ResultCode\n')
    print(f"  ✓ Regenerated exceptions submodule runtime __init__.py: {init_py_path}")


def postprocess_stubs(pyi_file_path: str):
    """Post-process the generated .pyi file to fix all stub issues."""
    print(f"Post-processing stubs: {pyi_file_path}")

    with open(pyi_file_path, 'r') as f:
        content = f.read()

    content = fix_imports(content, pyi_file_path)
    package_dir = os.path.dirname(pyi_file_path)

    if '__init__.pyi' in pyi_file_path:
        # Process main package __init__.pyi
        content = ensure_exports(content)
        # Exceptions are only available via aerospike_async.exceptions submodule
        # (handled by ensure_exceptions_submodule)
        ensure_exceptions_submodule(package_dir)

    elif '_aerospike_async_native.pyi' in pyi_file_path:
        # Process native module stub - replace placeholder policy stubs and add missing classes
        content = add_policy_stubs(content)
        # Note: PartitionFilter and PartitionStatus are generated by pyo3_stub_gen automatically
        content = add_record_stubs(content)
        content = add_key_stubs(content)
        content = add_operation_stubs(content)
        content = add_client_stubs(content)
        content = add_batch_policy_stubs(content)
        content = ensure_statement_set_name(content)

        # When processing native module, ensure package structure exists
        # Always create/regenerate main package __init__.pyi
        package_init_path = os.path.join(package_dir, '__init__.pyi')
        with open(package_init_path, 'w') as f:
            f.write('# This file is automatically generated by postprocess_stubs.py\n# ruff: noqa: E501\n\nfrom ._aerospike_async_native import *\n')
        print(f"  ✓ Regenerated package __init__.pyi: {package_init_path}")
        # Recursively process the new file
        postprocess_stubs(package_init_path)

        ensure_exceptions_submodule(package_dir)

    # Clean up blank lines - remove trailing whitespace from blank lines
    lines = content.split('\n')
    cleaned_lines = [line.rstrip() if line.strip() == '' else line for line in lines]
    content = '\n'.join(cleaned_lines)

    # Ensure file ends with a newline
    if not content.endswith('\n'):
        content += '\n'

    with open(pyi_file_path, 'w') as f:
        f.write(content)

    print(f"✓ Completed post-processing: {pyi_file_path}")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python postprocess_stubs.py <path_to_pyi_file>")
        sys.exit(1)

    pyi_file = sys.argv[1]
    if not os.path.exists(pyi_file):
        print(f"Error: File {pyi_file} does not exist")
        sys.exit(1)

    postprocess_stubs(pyi_file)
