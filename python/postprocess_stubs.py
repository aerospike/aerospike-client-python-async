#!/usr/bin/env python3
"""
Post-process the generated .pyi stub files to fix issues that pyo3_stub_gen cannot handle automatically.

This consolidated script replaces multiple separate stub processing scripts and handles:
1. Exception classes: create_exception! macro doesn't generate stubs, so we manually add them
2. Policy classes: PyClassInitializer return types don't generate complete method stubs for 
   ReadPolicy and WritePolicy, so we replace the placeholder with full method definitions
3. Import/export fixes: Ensures Key, Client, and Record are properly exported in __init__.pyi
4. Import cleanup: Fixes circular imports and uses relative imports where appropriate

All fixes are applied idempotently - safe to run multiple times.
"""

import os
import sys
import re


# Exception class stub definitions (defined once, reused everywhere)
EXCEPTION_STUB_CLASSES = '''class AerospikeError(builtins.Exception):
    """Base exception class for all Aerospike-specific errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ServerError(AerospikeError):
    """Exception raised when the Aerospike server returns an error."""
    def __init__(self, message: builtins.str) -> None: ...

class UDFBadResponse(AerospikeError):
    """Exception raised when a UDF (User Defined Function) returns a bad response."""
    def __init__(self, message: builtins.str) -> None: ...

class TimeoutError(AerospikeError):
    """Exception raised when an operation times out."""
    def __init__(self, message: builtins.str) -> None: ...

class Base64DecodeError(AerospikeError):
    """Exception raised when Base64 decoding fails."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidUTF8(AerospikeError):
    """Exception raised when invalid UTF-8 is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class IoError(AerospikeError):
    """Exception raised for I/O related errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseAddressError(AerospikeError):
    """Exception raised when parsing an address fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseIntError(AerospikeError):
    """Exception raised when parsing an integer fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ConnectionError(AerospikeError):
    """Exception raised when a connection error occurs."""
    def __init__(self, message: builtins.str) -> None: ...

class ValueError(AerospikeError):
    """Exception raised when an invalid value is provided."""
    def __init__(self, message: builtins.str) -> None: ...

class RecvError(AerospikeError):
    """Exception raised when receiving data fails."""
    def __init__(self, message: builtins.str) -> None: ...

class PasswordHashError(AerospikeError):
    """Exception raised when password hashing fails."""
    def __init__(self, message: builtins.str) -> None: ...

class BadResponse(AerospikeError):
    """Exception raised when a bad response is received."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidRustClientArgs(AerospikeError):
    """Exception raised when invalid arguments are provided to the Rust client."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidNodeError(AerospikeError):
    """Exception raised when an invalid node is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class NoMoreConnections(AerospikeError):
    """Exception raised when no more connections are available."""
    def __init__(self, message: builtins.str) -> None: ...

class ClientError(AerospikeError):
    """Exception raised for client-side errors."""
    def __init__(self, message: builtins.str) -> None: ...
'''

EXCEPTION_STUB__ALL__ = '''
__all__ = [
    "AerospikeError",
    "ServerError",
    "UDFBadResponse",
    "TimeoutError",
    "BadResponse",
    "ConnectionError",
    "InvalidNodeError",
    "NoMoreConnections",
    "RecvError",
    "Base64DecodeError",
    "InvalidUTF8",
    "ParseAddressError",
    "ParseIntError",
    "ValueError",
    "IoError",
    "PasswordHashError",
    "InvalidRustClientArgs",
    "ClientError",
]
'''

EXCEPTIONS_SUBMODULE_STUB = f'''# This file contains type stubs for the aerospike_async.exceptions submodule
# Generated by postprocess_stubs.py

import builtins

# Exception classes
{EXCEPTION_STUB_CLASSES}{EXCEPTION_STUB__ALL__}'''


def fix_imports(content: str, pyi_file_path: str = "") -> str:
    """Fix import statements to use relative imports and avoid circular dependencies."""
    # Fix absolute imports from aerospike_async._aerospike_async_native to relative imports
    content = re.sub(
        r'from aerospike_async\._aerospike_async_native import ([\w, ]+)',
        r'from ._aerospike_async_native import \1',
        content
    )
    # Fix any existing circular imports
    content = re.sub(
        r'^from aerospike_async import (Key|Record|Blob|GeoJSON|HLL|List|Map|Client)\b',
        r'from ._aerospike_async_native import \1',
        content,
        flags=re.MULTILINE
    )

    # Remove self-imports in _aerospike_async_native.pyi - types are now all in the same module
    if '_aerospike_async_native.pyi' in pyi_file_path:
        content = re.sub(
            r'^from _aerospike_async_native import [^\n]+\n',
            '',
            content,
            flags=re.MULTILINE
        )

    return content


def ensure_exports(content: str) -> str:
    """Ensure all classes are properly imported from _aerospike_async_native in __init__.pyi.

    The runtime __init__.py uses 'from ._aerospike_async_native import *', so the stub
    should match this for consistency. We also explicitly re-export Key, Client, and Record
    for better type checker support.
    """
    # Use 'import *' to match runtime behavior - all classes are available
    if 'from ._aerospike_async_native import *' not in content:
        # Replace any existing specific imports with wildcard import
        content = re.sub(
            r'from \._aerospike_async_native import [^\n]+\n',
            'from ._aerospike_async_native import *\n',
            content
        )
        # Or add it if no import exists
        if 'from ._aerospike_async_native' not in content:
            if 'import builtins' in content:
                content = re.sub(
                    r'(import builtins\n)',
                    r'\1from ._aerospike_async_native import *\n',
                    content
                )
            else:
                # Add at the beginning after any existing imports
                content = 'from ._aerospike_async_native import *\n' + content

    # Explicitly re-export commonly used classes for type checker clarity
    # Some type checkers don't fully resolve 'import *', so explicit re-exports help
    needed_exports = ['Key', 'Client', 'Record', 'ReadPolicy', 'WritePolicy', 'FilterExpression', 'BasePolicy']
    missing_exports = []
    for export in needed_exports:
        if not re.search(rf'^{export}\s*:\s*type\s*=\s*_aerospike_async_native\.{export}\b', content, re.MULTILINE):
            missing_exports.append(export)

    if missing_exports:
        class_match = re.search(r'^(class\s+\w+)', content, re.MULTILINE)
        if class_match:
            insert_pos = class_match.start()
            # Build re-exports - keep existing ones, add missing ones
            existing_lines = []
            new_lines = []
            for export in needed_exports:
                if export not in missing_exports:
                    # Extract existing line
                    existing_match = re.search(rf'^{export}\s*:\s*type\s*=\s*_aerospike_async_native\.{export}\b', content, re.MULTILINE)
                    if existing_match:
                        existing_lines.append((existing_match.start(), existing_match.end()))
                else:
                    new_lines.append(f'{export}: type = _aerospike_async_native.{export}')

            # Remove existing re-export section if it exists, then add complete one
            re_export_match = re.search(r'^# (Re-export|Explicit re-exports)', content, re.MULTILINE)
            if re_export_match:
                # Find the end of the re-export section (before next class or blank line)
                section_start = re_export_match.start()
                next_section = re.search(r'\n\n(?=class\s|\n#)', content[section_start:], re.MULTILINE)
                if next_section:
                    section_end = section_start + next_section.start() + 1
                    content = content[:section_start] + content[section_end:]
                    # Re-find class position after removal
                    class_match = re.search(r'^(class\s+\w+)', content, re.MULTILINE)
                    if class_match:
                        insert_pos = class_match.start()

            # Add all re-exports (both existing and new)
            all_exports = [f'{exp}: type = _aerospike_async_native.{exp}' for exp in needed_exports]
            re_exports = '# Explicit re-exports for type checking\n' + '\n'.join(all_exports) + '\n\n'
            content = content[:insert_pos] + re_exports + content[insert_pos:]

    return content


def add_client_stubs(content: str) -> str:
    """Add Client class stubs if missing (pyo3_stub_gen doesn't generate it when only referenced in override_return_type)."""
    client_stub = '''class Client:
    r"""
    Aerospike async client for database operations.
    Create instances using new_client() function.
    """
    def seeds(self) -> builtins.str: ...
    def close(self) -> typing.Awaitable[typing.Any]: ...
    def is_connected(self) -> typing.Awaitable[builtins.bool]: ...
    def put(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def get(self, policy: ReadPolicy, key: Key, bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Any]: ...
    def add(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def append(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def prepend(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def delete(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def touch(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists_legacy(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Tuple[Key, typing.Optional[typing.Any]]]: ...
    def truncate(self, namespace: builtins.str, set_name: builtins.str, before_nanos: typing.Optional[builtins.int] = None) -> typing.Awaitable[typing.Any]: ...
    def create_index(self, namespace: builtins.str, set_name: builtins.str, bin_name: builtins.str, index_name: builtins.str, index_type: IndexType, cit: typing.Optional[CollectionIndexType] = None) -> typing.Awaitable[typing.Any]: ...
    def drop_index(self, namespace: builtins.str, set_name: builtins.str, index_name: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def scan(self, policy: ScanPolicy, partition_filter: PartitionFilter, namespace: builtins.str, set_name: builtins.str, bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Any]: ...
    def query(self, policy: QueryPolicy, partition_filter: PartitionFilter, statement: Statement) -> typing.Awaitable[typing.Any]: ...
    def create_user(self, user: builtins.str, password: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def drop_user(self, user: builtins.str) -> typing.Awaitable[typing.Any]: ...
'''

    # Check if Client class is missing
    if 'class Client:' not in content:
        # Insert before new_client function
        new_client_match = re.search(r'^def new_client\(', content, re.MULTILINE)
        if new_client_match:
            insert_pos = new_client_match.start()
            content = content[:insert_pos] + client_stub + '\n' + content[insert_pos:]
            print("  ✓ Added Client class stubs (pyo3_stub_gen limitation)")
        else:
            # Insert at the end if new_client not found
            content = content + '\n' + client_stub
            print("  ✓ Added Client class stubs (at end)")

    return content


def add_policy_stubs(content: str) -> str:
    """Add full method stubs for WritePolicy and ReadPolicy classes."""
    read_policy_stub = '''class ReadPolicy(BasePolicy):
    def __new__(cls) -> ReadPolicy: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
'''

    write_policy_stub = '''class WritePolicy(BasePolicy):
    def __new__(cls) -> WritePolicy: ...
    @property
    def record_exists_action(self) -> RecordExistsAction: ...
    @record_exists_action.setter
    def record_exists_action(self, value: RecordExistsAction) -> None: ...
    @property
    def generation_policy(self) -> GenerationPolicy: ...
    @generation_policy.setter
    def generation_policy(self, value: GenerationPolicy) -> None: ...
    @property
    def commit_level(self) -> CommitLevel: ...
    @commit_level.setter
    def commit_level(self, value: CommitLevel) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
'''

    patterns = [
        (r'class ReadPolicy\(BasePolicy\):\s*\.\.\.', read_policy_stub, "ReadPolicy"),
        (r'class WritePolicy\(BasePolicy\):\s*\.\.\.', write_policy_stub, "WritePolicy"),
    ]

    for pattern, stub, name in patterns:
        if re.search(pattern, content):
            content = re.sub(pattern, stub.rstrip(), content)
            print(f"  ✓ Updated {name} class stubs")

    return content


def ensure_exceptions_submodule(package_dir: str):
    """Always regenerate the exceptions submodule stub file and runtime __init__.py."""
    exceptions_dir = os.path.join(package_dir, 'exceptions')
    os.makedirs(exceptions_dir, exist_ok=True)

    # Always write stub file for type checking (regenerate every time)
    init_stub_path = os.path.join(exceptions_dir, '__init__.pyi')
    with open(init_stub_path, 'w') as f:
        f.write(EXCEPTIONS_SUBMODULE_STUB)
    print(f"  ✓ Regenerated exceptions submodule stub: {init_stub_path}")

    # Always write runtime __init__.py (regenerate every time)
    # PyO3's create_exception! creates exceptions in aerospike_async.exceptions
    # The exceptions submodule is created by PyO3 when we call add_submodule
    # We need to access it from the parent package
    init_py_path = os.path.join(exceptions_dir, '__init__.py')
    with open(init_py_path, 'w') as f:
        f.write('# Exceptions are created by PyO3 in this submodule\n')
        f.write('# via create_exception!(aerospike_async.exceptions, ...) and add_submodule\n')
        f.write('# Users can import: from aerospike_async.exceptions import AerospikeError\n')
        f.write('\n')
        f.write('import sys\n')
        f.write('from .. import _aerospike_async_native\n')
        f.write('\n')
        f.write('# Access the exceptions submodule created by PyO3\n')
        f.write('_exceptions = getattr(_aerospike_async_native, "exceptions", None)\n')
        f.write('if _exceptions is None:\n')
        f.write('    raise ImportError("Exceptions submodule not found in native module")\n')
        f.write('\n')
        f.write('# Re-export all exception classes\n')
        f.write('AerospikeError = _exceptions.AerospikeError\n')
        f.write('ServerError = _exceptions.ServerError\n')
        f.write('UDFBadResponse = _exceptions.UDFBadResponse\n')
        f.write('TimeoutError = _exceptions.TimeoutError\n')
        f.write('BadResponse = _exceptions.BadResponse\n')
        f.write('ConnectionError = _exceptions.ConnectionError\n')
        f.write('InvalidNodeError = _exceptions.InvalidNodeError\n')
        f.write('NoMoreConnections = _exceptions.NoMoreConnections\n')
        f.write('RecvError = _exceptions.RecvError\n')
        f.write('Base64DecodeError = _exceptions.Base64DecodeError\n')
        f.write('InvalidUTF8 = _exceptions.InvalidUTF8\n')
        f.write('ParseAddressError = _exceptions.ParseAddressError\n')
        f.write('ParseIntError = _exceptions.ParseIntError\n')
        f.write('ValueError = _exceptions.ValueError\n')
        f.write('IoError = _exceptions.IoError\n')
        f.write('PasswordHashError = _exceptions.PasswordHashError\n')
        f.write('InvalidRustClientArgs = _exceptions.InvalidRustClientArgs\n')
        f.write('ClientError = _exceptions.ClientError\n')
    print(f"  ✓ Regenerated exceptions submodule runtime __init__.py: {init_py_path}")


def postprocess_stubs(pyi_file_path: str):
    """Post-process the generated .pyi file to fix all stub issues."""
    print(f"Post-processing stubs: {pyi_file_path}")

    with open(pyi_file_path, 'r') as f:
        content = f.read()

    content = fix_imports(content, pyi_file_path)
    package_dir = os.path.dirname(pyi_file_path)

    if '__init__.pyi' in pyi_file_path:
        # Process main package __init__.pyi
        content = ensure_exports(content)
        # Exceptions are only available via aerospike_async.exceptions submodule
        # (handled by ensure_exceptions_submodule)
        ensure_exceptions_submodule(package_dir)

    elif '_aerospike_async_native.pyi' in pyi_file_path:
        # Process native module stub - replace placeholder policy stubs and add Client class
        content = add_policy_stubs(content)
        content = add_client_stubs(content)

        # When processing native module, ensure package structure exists
        # Always create/regenerate main package __init__.pyi
        package_init_path = os.path.join(package_dir, '__init__.pyi')
        with open(package_init_path, 'w') as f:
            f.write('# This file is automatically generated by postprocess_stubs.py\n# ruff: noqa: E501\n\nfrom ._aerospike_async_native import *\n')
        print(f"  ✓ Regenerated package __init__.pyi: {package_init_path}")
        # Recursively process the new file
        postprocess_stubs(package_init_path)

        ensure_exceptions_submodule(package_dir)

    # Clean up blank lines - remove trailing whitespace from blank lines
    lines = content.split('\n')
    cleaned_lines = [line.rstrip() if line.strip() == '' else line for line in lines]
    content = '\n'.join(cleaned_lines)

    # Ensure file ends with a newline
    if not content.endswith('\n'):
        content += '\n'

    with open(pyi_file_path, 'w') as f:
        f.write(content)

    print(f"✓ Completed post-processing: {pyi_file_path}")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python postprocess_stubs.py <path_to_pyi_file>")
        sys.exit(1)

    pyi_file = sys.argv[1]
    if not os.path.exists(pyi_file):
        print(f"Error: File {pyi_file} does not exist")
        sys.exit(1)

    postprocess_stubs(pyi_file)
