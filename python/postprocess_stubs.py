#!/usr/bin/env python3
"""
Post-process the generated .pyi stub files to fix issues that pyo3_stub_gen cannot handle automatically.

This consolidated script replaces multiple separate stub processing scripts and handles:
1. Exception classes: create_exception! macro doesn't generate stubs, so we manually add them
2. Policy classes: PyClassInitializer return types don't generate complete method stubs for 
   ReadPolicy and WritePolicy, so we replace the placeholder with full method definitions
3. Import/export fixes: Ensures Key, Client, and Record are properly exported in __init__.pyi
4. Import cleanup: Fixes circular imports and uses relative imports where appropriate

All fixes are applied idempotently - safe to run multiple times.
"""

import os
import sys
import re


# Exception class stub definitions (defined once, reused everywhere)
EXCEPTION_STUB_CLASSES = '''class AerospikeError(builtins.Exception):
    """Base exception class for all Aerospike-specific errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ServerError(AerospikeError):
    """Exception raised when the Aerospike server returns an error."""
    def __init__(self, message: builtins.str) -> None: ...

class UDFBadResponse(AerospikeError):
    """Exception raised when a UDF (User Defined Function) returns a bad response."""
    def __init__(self, message: builtins.str) -> None: ...

class TimeoutError(AerospikeError):
    """Exception raised when an operation times out."""
    def __init__(self, message: builtins.str) -> None: ...

class Base64DecodeError(AerospikeError):
    """Exception raised when Base64 decoding fails."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidUTF8(AerospikeError):
    """Exception raised when invalid UTF-8 is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class IoError(AerospikeError):
    """Exception raised for I/O related errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseAddressError(AerospikeError):
    """Exception raised when parsing an address fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseIntError(AerospikeError):
    """Exception raised when parsing an integer fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ConnectionError(AerospikeError):
    """Exception raised when a connection error occurs."""
    def __init__(self, message: builtins.str) -> None: ...

class ValueError(AerospikeError):
    """Exception raised when an invalid value is provided."""
    def __init__(self, message: builtins.str) -> None: ...

class RecvError(AerospikeError):
    """Exception raised when receiving data fails."""
    def __init__(self, message: builtins.str) -> None: ...

class PasswordHashError(AerospikeError):
    """Exception raised when password hashing fails."""
    def __init__(self, message: builtins.str) -> None: ...

class BadResponse(AerospikeError):
    """Exception raised when a bad response is received."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidRustClientArgs(AerospikeError):
    """Exception raised when invalid arguments are provided to the Rust client."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidNodeError(AerospikeError):
    """Exception raised when an invalid node is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class NoMoreConnections(AerospikeError):
    """Exception raised when no more connections are available."""
    def __init__(self, message: builtins.str) -> None: ...
'''

EXCEPTION_STUB__ALL__ = '''
__all__ = [
    "AerospikeError",
    "ServerError",
    "UDFBadResponse",
    "TimeoutError",
    "BadResponse",
    "ConnectionError",
    "InvalidNodeError",
    "NoMoreConnections",
    "RecvError",
    "Base64DecodeError",
    "InvalidUTF8",
    "ParseAddressError",
    "ParseIntError",
    "ValueError",
    "IoError",
    "PasswordHashError",
    "InvalidRustClientArgs",
]
'''

EXCEPTIONS_SUBMODULE_STUB = f'''# This file contains type stubs for the aerospike_async.exceptions submodule
# Generated by postprocess_stubs.py

import builtins

# Exception classes
{EXCEPTION_STUB_CLASSES}{EXCEPTION_STUB__ALL__}'''


def fix_imports(content: str, pyi_file_path: str = "") -> str:
    """Fix import statements to use relative imports and avoid circular dependencies."""
    # Fix absolute imports from aerospike_async._aerospike_async_native to relative imports
    content = re.sub(
        r'from aerospike_async\._aerospike_async_native import ([\w, ]+)',
        r'from ._aerospike_async_native import \1',
        content
    )
    # Fix any existing circular imports
    content = re.sub(
        r'^from aerospike_async import (Key|Record|Blob|GeoJSON|HLL|List|Map|Client)\b',
        r'from ._aerospike_async_native import \1',
        content,
        flags=re.MULTILINE
    )

    # Remove self-imports in _aerospike_async_native.pyi - types are now all in the same module
    if '_aerospike_async_native.pyi' in pyi_file_path:
        content = re.sub(
            r'^from _aerospike_async_native import [^\n]+\n',
            '',
            content,
            flags=re.MULTILINE
        )

    return content


def ensure_exports(content: str) -> str:
    """Ensure all classes are properly imported from _aerospike_async_native in __init__.pyi.

    The runtime __init__.py uses 'from ._aerospike_async_native import *', so the stub
    should match this for consistency. We also explicitly re-export Key, Client, and Record
    for better type checker support.
    """
    # Use 'import *' to match runtime behavior - all classes are available
    if 'from ._aerospike_async_native import *' not in content:
        # Replace any existing specific imports with wildcard import
        content = re.sub(
            r'from \._aerospike_async_native import [^\n]+\n',
            'from ._aerospike_async_native import *\n',
            content
        )
        # Or add it if no import exists
        if 'from ._aerospike_async_native' not in content:
            if 'import builtins' in content:
                content = re.sub(
                    r'(import builtins\n)',
                    r'\1from ._aerospike_async_native import *\n',
                    content
                )
            else:
                # Add at the beginning after any existing imports
                content = 'from ._aerospike_async_native import *\n' + content

    # Explicitly re-export commonly used classes for type checker clarity
    # Some type checkers don't fully resolve 'import *', so explicit re-exports help
    needed_exports = ['Key', 'Client', 'Record', 'ReadPolicy', 'WritePolicy', 'FilterExpression', 'BasePolicy']
    missing_exports = []
    for export in needed_exports:
        if not re.search(rf'^{export}\s*:\s*type\s*=\s*_aerospike_async_native\.{export}\b', content, re.MULTILINE):
            missing_exports.append(export)

    if missing_exports:
        class_match = re.search(r'^(class\s+\w+)', content, re.MULTILINE)
        if class_match:
            insert_pos = class_match.start()
            # Build re-exports - keep existing ones, add missing ones
            existing_lines = []
            new_lines = []
            for export in needed_exports:
                if export not in missing_exports:
                    # Extract existing line
                    existing_match = re.search(rf'^{export}\s*:\s*type\s*=\s*_aerospike_async_native\.{export}\b', content, re.MULTILINE)
                    if existing_match:
                        existing_lines.append((existing_match.start(), existing_match.end()))
                else:
                    new_lines.append(f'{export}: type = _aerospike_async_native.{export}')

            # Remove existing re-export section if it exists, then add complete one
            re_export_match = re.search(r'^# (Re-export|Explicit re-exports)', content, re.MULTILINE)
            if re_export_match:
                # Find the end of the re-export section (before next class or blank line)
                section_start = re_export_match.start()
                next_section = re.search(r'\n\n(?=class\s|\n#)', content[section_start:], re.MULTILINE)
                if next_section:
                    section_end = section_start + next_section.start() + 1
                    content = content[:section_start] + content[section_end:]
                    # Re-find class position after removal
                    class_match = re.search(r'^(class\s+\w+)', content, re.MULTILINE)
                    if class_match:
                        insert_pos = class_match.start()

            # Add all re-exports (both existing and new)
            all_exports = [f'{exp}: type = _aerospike_async_native.{exp}' for exp in needed_exports]
            re_exports = '# Explicit re-exports for type checking\n' + '\n'.join(all_exports) + '\n\n'
            content = content[:insert_pos] + re_exports + content[insert_pos:]

    return content


def add_policy_stubs(content: str) -> str:
    """Add full method stubs for WritePolicy and ReadPolicy classes."""
    read_policy_stub = '''class ReadPolicy(BasePolicy):
    def __new__(cls) -> ReadPolicy: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
'''

    write_policy_stub = '''class WritePolicy(BasePolicy):
    def __new__(cls) -> WritePolicy: ...
    @property
    def record_exists_action(self) -> RecordExistsAction: ...
    @record_exists_action.setter
    def record_exists_action(self, value: RecordExistsAction) -> None: ...
    @property
    def generation_policy(self) -> GenerationPolicy: ...
    @generation_policy.setter
    def generation_policy(self, value: GenerationPolicy) -> None: ...
    @property
    def commit_level(self) -> CommitLevel: ...
    @commit_level.setter
    def commit_level(self, value: CommitLevel) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
'''

    patterns = [
        (r'class ReadPolicy\(BasePolicy\):\s*\.\.\.', read_policy_stub, "ReadPolicy"),
        (r'class WritePolicy\(BasePolicy\):\s*\.\.\.', write_policy_stub, "WritePolicy"),
    ]

    for pattern, stub, name in patterns:
        if re.search(pattern, content):
            content = re.sub(pattern, stub.rstrip(), content)
            print(f"  ✓ Updated {name} class stubs")

    return content


def ensure_exceptions_submodule(package_dir: str):
    """Always regenerate the exceptions submodule stub file and runtime __init__.py."""
    exceptions_dir = os.path.join(package_dir, 'exceptions')
    os.makedirs(exceptions_dir, exist_ok=True)

    # Always write stub file for type checking (regenerate every time)
    init_stub_path = os.path.join(exceptions_dir, '__init__.pyi')
    with open(init_stub_path, 'w') as f:
        f.write(EXCEPTIONS_SUBMODULE_STUB)
    print(f"  ✓ Regenerated exceptions submodule stub: {init_stub_path}")

    # Always write runtime __init__.py (regenerate every time)
    init_py_path = os.path.join(exceptions_dir, '__init__.py')
    with open(init_py_path, 'w') as f:
        f.write('# Import exceptions from the compiled native module\n')
        f.write('# Exceptions are registered in Rust and available from the parent module\n')
        f.write('from .._aerospike_async_native import (\n')
        f.write('    AerospikeError,\n')
        f.write('    ServerError,\n')
        f.write('    UDFBadResponse,\n')
        f.write('    TimeoutError,\n')
        f.write('    BadResponse,\n')
        f.write('    ConnectionError,\n')
        f.write('    InvalidNodeError,\n')
        f.write('    NoMoreConnections,\n')
        f.write('    RecvError,\n')
        f.write('    Base64DecodeError,\n')
        f.write('    InvalidUTF8,\n')
        f.write('    ParseAddressError,\n')
        f.write('    ParseIntError,\n')
        f.write('    ValueError,\n')
        f.write('    IoError,\n')
        f.write('    PasswordHashError,\n')
        f.write('    InvalidRustClientArgs,\n')
        f.write(')\n')
    print(f"  ✓ Regenerated exceptions submodule runtime __init__.py: {init_py_path}")


def add_exception_stubs_to_content(content: str) -> str:
    """Add exception class stubs to __init__.pyi content if not already present."""
    if 'class AerospikeError(' not in content:
        exception_stubs = '\n# Exception classes (added by post-processing script)\n' + EXCEPTION_STUB_CLASSES
        content = content + exception_stubs
        print("  ✓ Added exception class stubs")
    return content


def postprocess_stubs(pyi_file_path: str):
    """Post-process the generated .pyi file to fix all stub issues."""
    print(f"Post-processing stubs: {pyi_file_path}")

    with open(pyi_file_path, 'r') as f:
        content = f.read()

    content = fix_imports(content, pyi_file_path)
    package_dir = os.path.dirname(pyi_file_path)

    if '__init__.pyi' in pyi_file_path:
        # Process main package __init__.pyi
        content = ensure_exports(content)
        content = add_exception_stubs_to_content(content)
        ensure_exceptions_submodule(package_dir)

    elif '_aerospike_async_native.pyi' in pyi_file_path:
        # Process native module stub - replace placeholder policy stubs
        content = add_policy_stubs(content)

        # When processing native module, ensure package structure exists
        # Always create/regenerate main package __init__.pyi
        package_init_path = os.path.join(package_dir, '__init__.pyi')
        with open(package_init_path, 'w') as f:
            f.write('# This file is automatically generated by postprocess_stubs.py\n# ruff: noqa: E501\n\nfrom ._aerospike_async_native import *\n')
        print(f"  ✓ Regenerated package __init__.pyi: {package_init_path}")
        # Recursively process the new file
        postprocess_stubs(package_init_path)

        ensure_exceptions_submodule(package_dir)

    with open(pyi_file_path, 'w') as f:
        f.write(content)

    print(f"✓ Completed post-processing: {pyi_file_path}")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python postprocess_stubs.py <path_to_pyi_file>")
        sys.exit(1)

    pyi_file = sys.argv[1]
    if not os.path.exists(pyi_file):
        print(f"Error: File {pyi_file} does not exist")
        sys.exit(1)

    postprocess_stubs(pyi_file)
