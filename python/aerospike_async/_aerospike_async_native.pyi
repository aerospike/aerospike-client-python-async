# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import aerospike_async
import builtins
import typing
from ._aerospike_async_native import GeoJSON, Key, Record
from enum import Enum

class AdminPolicy:
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    def __new__(cls) -> AdminPolicy: ...

class BasePolicy:
    @property
    def consistency_level(self) -> ConsistencyLevel: ...
    @consistency_level.setter
    def consistency_level(self, value: ConsistencyLevel) -> None: ...
    @property
    def total_timeout(self) -> builtins.int: ...
    @total_timeout.setter
    def total_timeout(self, value: builtins.int) -> None: ...
    @property
    def max_retries(self) -> builtins.int: ...
    @max_retries.setter
    def max_retries(self, value: builtins.int) -> None: ...
    @property
    def sleep_between_retries(self) -> builtins.int: ...
    @sleep_between_retries.setter
    def sleep_between_retries(self, value: builtins.int) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    @property
    def socket_timeout(self) -> builtins.int: ...
    @socket_timeout.setter
    def socket_timeout(self, value: builtins.int) -> None: ...
    def __new__(cls) -> BasePolicy: ...

class BatchDeletePolicy:
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    def __new__(cls) -> BatchDeletePolicy: ...

class BatchPolicy(BasePolicy):
    ...
    @property
    def allow_inline(self) -> builtins.bool: ...
    @allow_inline.setter
    def allow_inline(self, value: builtins.bool) -> None: ...
    @property
    def allow_inline_ssd(self) -> builtins.bool: ...
    @allow_inline_ssd.setter
    def allow_inline_ssd(self, value: builtins.bool) -> None: ...
    @property
    def respond_all_keys(self) -> builtins.bool: ...
    @respond_all_keys.setter
    def respond_all_keys(self, value: builtins.bool) -> None: ...

class BatchReadPolicy:
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    @property
    def read_touch_ttl(self) -> builtins.int: ...
    @read_touch_ttl.setter
    def read_touch_ttl(self, value: builtins.int) -> None: ...
    def __new__(cls) -> BatchReadPolicy: ...

class BatchRecord:
    @property
    def key(self) -> Key: ...
    @property
    def record(self) -> typing.Optional[Record]:
        r"""
        Get the record from this batch result.

        **Performance Note:** This method clones the Record data on each call.
        The amount of data cloned depends on the record size (bins, metadata, etc.).
        For optimal performance when accessing the record multiple times, cache the result in Python:

        results = await client.batch_read(bp, brp, keys, None)
        for batch_record in results:
            record = batch_record.record  # Clone once
            if record:
                # Use record multiple times - no additional cloning
                bins = record.bins
                key = record.key
                generation = record.generation

        Returns:
            Optional[Record]: The record if present, None otherwise.
        """
    @property
    def result_code(self) -> typing.Optional[ResultCode]: ...
    @property
    def in_doubt(self) -> builtins.bool: ...

class BatchUDFPolicy:
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
    def __new__(cls) -> BatchUDFPolicy: ...

class BatchWritePolicy:
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    def __new__(cls) -> BatchWritePolicy: ...

class BitPolicy:
    def __new__(cls, write_flags:typing.Optional[BitwiseWriteFlags]) -> BitPolicy:
        r"""
        Create a new BitPolicy with the specified write flags.
        Default is default write flags.
        """
    def get_write_flags(self) -> builtins.int:
        r"""
        Get the write flags.
        """
    def set_write_flags(self, flags:BitwiseWriteFlags) -> None:
        r"""
        Set the write flags.
        """

class CTX:
    r"""
    Context for nested CDT (Complex Data Type) operations.
    Used to specify the location of nested lists/maps within a record.
    """
    def __eq__(self, other:CTX) -> builtins.bool:
        r"""
        Compare two CTX objects for equality.
        """
    @staticmethod
    def list_index(index:builtins.int) -> CTX:
        r"""
        Lookup list by index offset.
        If the index is negative, the resolved index starts backwards from end of list.
        Examples: 0 = first item, 4 = fifth item, -1 = last item, -3 = third to last item.
        """
    @staticmethod
    def list_index_create(index:builtins.int, order:ListOrderType, pad:builtins.bool) -> CTX:
        r"""
        Create list with given type at index offset, given an order and pad.
        """
    @staticmethod
    def list_rank(rank:builtins.int) -> CTX:
        r"""
        Lookup list by rank.
        0 = smallest value, N = Nth smallest value, -1 = largest value.
        """
    @staticmethod
    def list_value(value:typing.Any) -> CTX:
        r"""
        Lookup list by value.
        """
    @staticmethod
    def map_index(key:typing.Any) -> CTX:
        r"""
        Lookup map by index offset.
        If the index is negative, the resolved index starts backwards from end of list.
        """
    @staticmethod
    def map_rank(rank:builtins.int) -> CTX:
        r"""
        Lookup map by rank.
        0 = smallest value, N = Nth smallest value, -1 = largest value.
        """
    @staticmethod
    def map_key(key:typing.Any) -> CTX:
        r"""
        Lookup map by key.
        """
    @staticmethod
    def map_key_create(key:typing.Any, order:MapOrder) -> CTX:
        r"""
        Create map with given type at map key.
        """
    @staticmethod
    def map_value(value:typing.Any) -> CTX:
        r"""
        Lookup map by value.
        Converts HashMap to BTreeMap (OrderedMap) for exact byte-level matching to ensure consistent serialization.
        """

class ClientPolicy:
    @property
    def user(self) -> typing.Optional[builtins.str]: ...
    @user.setter
    def user(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def password(self) -> typing.Optional[builtins.str]: ...
    @password.setter
    def password(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def auth_mode(self) -> AuthMode:
        r"""
        Get the current authentication mode.
        """
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    @property
    def idle_timeout(self) -> builtins.int:
        r"""
        Connection idle timeout. Every time a connection is used, its idle
        deadline will be extended by this duration. When this deadline is reached,
        the connection will be closed and discarded from the connection pool.
        """
    @idle_timeout.setter
    def idle_timeout(self, value: builtins.int) -> None: ...
    @property
    def max_conns_per_node(self) -> builtins.int: ...
    @max_conns_per_node.setter
    def max_conns_per_node(self, value: builtins.int) -> None: ...
    @property
    def conn_pools_per_node(self) -> builtins.int:
        r"""
        Number of connection pools used for each node. Machines with 8 CPU cores or less usually
        need only one connection pool per node. Machines with larger number of CPU cores may have
        their performance limited by contention for pooled connections. Contention for pooled
        connections can be reduced by creating multiple mini connection pools per node.
        """
    @conn_pools_per_node.setter
    def conn_pools_per_node(self, value: builtins.int) -> None: ...
    @property
    def use_services_alternate(self) -> builtins.bool:
        r"""
        UseServicesAlternate determines if the client should use "services-alternate"
        instead of "services" in info request during cluster tending.
        "services-alternate" returns server configured external IP addresses that client
        uses to talk to nodes.  "services-alternate" can be used in place of
        providing a client "ipMap".
        This feature is recommended instead of using the client-side IpMap above.

        "services-alternate" is available with Aerospike Server versions >= 3.7.1.
        """
    @use_services_alternate.setter
    def use_services_alternate(self, value: builtins.bool) -> None: ...
    @property
    def rack_ids(self) -> typing.Optional[builtins.list[builtins.int]]:
        r"""
        Mark this client as belonging to a rack, and track server rack data.  This field is useful when directing read commands to
        the server node that contains the key and exists on the same rack as the client.
        This serves to lower cloud provider costs when nodes are distributed across different
        racks/data centers.

        Replica.PreferRack and server rack configuration must
        also be set to enable this functionality.
        """
    @rack_ids.setter
    def rack_ids(self, value: typing.Optional[builtins.list[builtins.int]]) -> None: ...
    @property
    def fail_if_not_connected(self) -> builtins.bool:
        r"""
        Size of the thread pool used in scan and query commands. These commands are often sent to
        multiple server nodes in parallel threads. A thread pool improves performance because
        threads do not have to be created/destroyed for each command.
        Throw exception if host connection fails during addHost().
        """
    @fail_if_not_connected.setter
    def fail_if_not_connected(self, value: builtins.bool) -> None: ...
    @property
    def buffer_reclaim_threshold(self) -> builtins.int:
        r"""
        Threshold at which the buffer attached to the connection will be shrunk by deallocating
        memory instead of just resetting the size of the underlying vec.
        Should be set to a value that covers as large a percentile of payload sizes as possible,
        while also being small enough not to occupy a significant amount of memory for the life
        of the connection pool.
        """
    @buffer_reclaim_threshold.setter
    def buffer_reclaim_threshold(self, value: builtins.int) -> None: ...
    @property
    def tend_interval(self) -> builtins.int:
        r"""
        TendInterval determines interval for checking for cluster state changes.
        Minimum possible interval is 10 Milliseconds.
        """
    @tend_interval.setter
    def tend_interval(self, value: builtins.int) -> None: ...
    @property
    def ip_map(self) -> typing.Any:
        r"""
        A IP translation table is used in cases where different clients
        use different server IP addresses.  This may be necessary when
        using clients from both inside and outside a local area
        network. Default is no translation.
        The key is the IP address returned from friend info requests to other servers.
        The value is the real IP address used to connect to the server.
        """
    @ip_map.setter
    def ip_map(self, value: typing.Optional[dict]) -> None: ...
    @property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        r"""
        Expected cluster name. It not `None`, server nodes must return this cluster name in order
        to join the client's view of the cluster. Should only be set when connecting to servers
        that support the "cluster-name" info command.
        """
    @cluster_name.setter
    def cluster_name(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def tls_config(self) -> typing.Optional[None]:
        r"""
        TLS configuration for secure connections.
        Set to None to disable TLS, or use TlsConfig to configure TLS.
        """
    @tls_config.setter
    def tls_config(self, value: typing.Optional[None]) -> None: ...
    def __new__(cls) -> ClientPolicy: ...
    def set_auth_mode(self, mode:AuthMode, user:typing.Optional[builtins.str]=None, password:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the authentication mode.

        Args:
            mode: The authentication mode (AuthMode.NONE, AuthMode.INTERNAL, AuthMode.EXTERNAL, or AuthMode.PKI)
            user: Optional username (required for INTERNAL and EXTERNAL modes)
            password: Optional password (required for INTERNAL and EXTERNAL modes)

        Note: For PKI mode, user and password are ignored. TLS with client certificate is required.
        """
    def set_pki_auth(self) -> None:
        r"""
        Set authentication mode to PKI (certificate-based authentication).

        This requires TLS to be configured with a client certificate.
        Requires server version 5.7.0+.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __copy__(self) -> ClientPolicy: ...
    def __deepcopy__(self, _memo:dict) -> ClientPolicy: ...

class Expiration:
    NAMESPACE_DEFAULT: Expiration = ...
    NEVER_EXPIRE: Expiration = ...
    DONT_UPDATE: Expiration = ...
    @staticmethod
    def seconds(s:builtins.int) -> Expiration: ...
    def __richcmp__(self, other:Expiration, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...

class Filter:
    r"""
    Query filter definition. Currently, only one filter is allowed in a Statement, and must be on a
    bin which has a secondary index defined.

    Filter instances should be instantiated using one of the provided macros:

    - `as_eq`
    - `as_range`
    - `as_contains`
    - `as_contains_range`
    - `as_within_region`
    - `as_within_radius`
    - `as_regions_containing_point`
    """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    @staticmethod
    def equal(bin_name:builtins.str, value:typing.Any) -> Filter: ...
    @staticmethod
    def range(bin_name:builtins.str, begin:typing.Any, end:typing.Any) -> Filter: ...
    @staticmethod
    def contains(bin_name:builtins.str, value:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def contains_range(bin_name:builtins.str, begin:typing.Any, end:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_region(bin_name:builtins.str, region:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_radius(bin_name:builtins.str, lng:builtins.float, lat:builtins.float, radius:builtins.float, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def regions_containing_point(bin_name:builtins.str, point:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...

class FilterExpression:
    r"""
    Filter expression, which can be applied to most commands, to control which records are
    affected by the command.
    """
    @staticmethod
    def key(exp_type:ExpType) -> FilterExpression:
        r"""
        Create a record key expression of specified type.
        """
    @staticmethod
    def key_exists() -> FilterExpression:
        r"""
        Create function that returns if the primary key is stored in the record meta data
        as a boolean expression. This would occur when `send_key` is true on record write.
        """
    @staticmethod
    def int_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit int bin expression.
        """
    @staticmethod
    def string_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create string bin expression.
        """
    @staticmethod
    def blob_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create blob bin expression.
        """
    @staticmethod
    def bool_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create boolean bin expression.
        """
    @staticmethod
    def float_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit float bin expression.
        """
    @staticmethod
    def geo_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create geo bin expression.
        """
    @staticmethod
    def list_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create list bin expression.
        """
    @staticmethod
    def map_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create map bin expression.
        """
    @staticmethod
    def hll_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create a HLL bin expression
        """
    @staticmethod
    def bin_exists(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns if bin of specified name exists.
        """
    @staticmethod
    def bin_type(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns bin's integer particle type.
        """
    @staticmethod
    def set_name() -> FilterExpression:
        r"""
        Create function that returns record set name string.
        """
    @staticmethod
    def record_size() -> FilterExpression:
        r"""
        Create expression that returns the record size. Usually evaluates quickly because
        record metadata is cached in memory. Requires server version 7.0+.
        """
    @staticmethod
    def device_size() -> FilterExpression:
        r"""
        Create function that returns record size on disk. If server storage-engine is
        memory, then zero is returned. Deprecated: use record_size() for server version 7.0+.
        Implemented via record_size() for server 7.0+.
        """
    @staticmethod
    def memory_size() -> FilterExpression:
        r"""
        Create expression that returns record size in memory. Deprecated: use record_size() for server 7.0+.
        Implemented via record_size() for server 7.0+.
        """
    @staticmethod
    def last_update() -> FilterExpression:
        r"""
        Create function that returns record last update time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def since_update() -> FilterExpression:
        r"""
        Create expression that returns milliseconds since the record was last updated.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def void_time() -> FilterExpression:
        r"""
        Create function that returns record expiration time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def ttl() -> FilterExpression:
        r"""
        Create function that returns record expiration time (time to live) in integer seconds.
        """
    @staticmethod
    def is_tombstone() -> FilterExpression:
        r"""
        Create expression that returns if record has been deleted and is still in tombstone state.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def digest_modulo(modulo:builtins.int) -> FilterExpression:
        r"""
        Create function that returns record digest modulo as integer.
        """
    @staticmethod
    def regex_compare(regex:builtins.str, flags:builtins.int, bin:FilterExpression) -> FilterExpression:
        r"""
        Create function like regular expression string operation.
        """
    @staticmethod
    def geo_compare(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create compare geospatial operation.
        """
    @staticmethod
    def int_val(val:builtins.int) -> FilterExpression:
        r"""
        Creates 64 bit integer value
        """
    @staticmethod
    def bool_val(val:builtins.bool) -> FilterExpression:
        r"""
        Creates a Boolean value
        """
    @staticmethod
    def string_val(val:builtins.str) -> FilterExpression:
        r"""
        Creates String bin value
        """
    @staticmethod
    def float_val(val:builtins.float) -> FilterExpression:
        r"""
        Creates 64 bit float bin value
        """
    @staticmethod
    def blob_val(val:typing.Sequence[builtins.int]) -> FilterExpression:
        r"""
        Creates Blob bin value
        """
    @staticmethod
    def list_val(val:typing.Sequence[typing.Any]) -> FilterExpression:
        r"""
        Create List bin value.
        """
    @staticmethod
    def map_val(val:typing.Any) -> FilterExpression:
        r"""
        Create Map bin value.
        Converts HashMap to BTreeMap (OrderedMap) for exact byte-level matching.
        map_val accepts both HashMap and BTreeMap (OrderedMap) via the MapLike trait.
        We use BTreeMap to ensure deterministic key ordering for serialization matching.
        """
    @staticmethod
    def geo_val(val:builtins.str) -> FilterExpression:
        r"""
        Create geospatial json string value.
        """
    @staticmethod
    def nil() -> FilterExpression:
        r"""
        Create a Nil PHPValue
        """
    @staticmethod
    def not_(exp:FilterExpression) -> FilterExpression:
        r"""
        Create "not" operator expression.
        """
    @staticmethod
    def and_(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "and" (&&) operator that applies to a variable number of expressions.
        // (a > 5 || a == 0) && b < 3
        """
    @staticmethod
    def or_(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "or" (||) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "xor" (^) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def eq(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create equal (==) expression.
        """
    @staticmethod
    def ne(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create not equal (!=) expression
        """
    @staticmethod
    def gt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than (>) operation.
        """
    @staticmethod
    def ge(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than or equal (>=) operation.
        """
    @staticmethod
    def lt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than (<) operation.
        """
    @staticmethod
    def le(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than or equals (<=) operation.
        """
    @staticmethod
    def num_add(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "add" (+) operator that applies to a variable number of expressions.
        Return sum of all `FilterExpressions` given. All arguments must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_sub(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "subtract" (-) operator that applies to a variable number of expressions.
        If only one `FilterExpressions` is provided, return the negation of that argument.
        Otherwise, return the sum of the 2nd to Nth `FilterExpressions` subtracted from the 1st
        `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mul(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "multiply" (*) operator that applies to a variable number of expressions.
        Return the product of all `FilterExpressions`. If only one `FilterExpressions` is supplied, return
        that `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_div(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "divide" (/) operator that applies to a variable number of expressions.
        If there is only one `FilterExpressions`, returns the reciprocal for that `FilterExpressions`.
        Otherwise, return the first `FilterExpressions` divided by the product of the rest.
        All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_pow(base:FilterExpression, exponent:FilterExpression) -> FilterExpression:
        r"""
        Create "power" operator that raises a "base" to the "exponent" power.
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_log(num:FilterExpression, base:FilterExpression) -> FilterExpression:
        r"""
        Create "log" operator for logarithm of "num" with base "base".
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mod(numerator:FilterExpression, denominator:FilterExpression) -> FilterExpression:
        r"""
        Create "modulo" (%) operator that determines the remainder of "numerator"
        divided by "denominator". All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_abs(value:FilterExpression) -> FilterExpression:
        r"""
        Create operator that returns absolute value of a number.
        All arguments must resolve to integer or float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_floor(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number down to the closest integer value.
        The return type is float.
        """
    @staticmethod
    def num_ceil(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number up to the closest integer value.
        The return type is float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_int(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts an integer to a float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_float(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts a float to an integer.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_and(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "and" (&) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_or(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "or" (|) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "xor" (^) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_not(exp:FilterExpression) -> FilterExpression:
        r"""
        Create integer "not" (~) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_lshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "left shift" (<<) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "logical right shift" (>>>) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_arshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "arithmetic right shift" (>>) operator.
        The sign bit is preserved and not shifted.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_count(exp:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns count of integer bits that are set to 1.
        Requires server version 5.6.0+
        """
    @staticmethod
    def int_lscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from left (most significant bit) to
        right (least significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from right (least significant bit) to
        left (most significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def min(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the minimum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def max(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the maximum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def cond(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Conditionally select an expression from a variable number of expression pairs
        followed by default expression action.
        Requires server version 5.6.0+.
        ```
        // Args Format: bool exp1, action exp1, bool exp2, action exp2, ..., action-default
        // Apply operator based on type.
        """
    @staticmethod
    def exp_let(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Define variables and expressions in scope.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def def_(name:builtins.str, value:FilterExpression) -> FilterExpression:
        r"""
        Assign variable to an expression that can be accessed later.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def var(name:builtins.str) -> FilterExpression:
        r"""
        Retrieve expression value from a variable.
        Requires server version 5.6.0+.
        """
    def __richcmp__(self, other:FilterExpression, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def _debug_inner(self) -> builtins.str:
        r"""
        Return the debug representation of the inner expression (used for equality).
        Exposed for inspection; same string used by __eq__.
        """
    @staticmethod
    def unknown() -> FilterExpression:
        r"""
        Create unknown value. Used to intentionally fail an expression.
        The failure can be ignored with `ExpWriteFlags` `EVAL_NO_FAIL`
        or `ExpReadFlags` `EVAL_NO_FAIL`.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def list_size(bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that returns list size.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_index(return_type:ListReturnType, value_type:ExpType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list item identified by index and returns
        selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_rank(return_type:ListReturnType, value_type:ExpType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list item identified by rank and returns
        selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_value(return_type:ListReturnType, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items identified by value and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_value_range(return_type:ListReturnType, value_begin:typing.Optional[FilterExpression], value_end:typing.Optional[FilterExpression], bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items identified by value range (valueBegin inclusive, valueEnd exclusive)
        and returns selected data specified by returnType.
        If valueBegin is None, the range is less than valueEnd. If valueEnd is None, the range is greater than equal to valueBegin.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_value_list(return_type:ListReturnType, values:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items identified by values and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_index_range(return_type:ListReturnType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items starting at specified index to the end of list
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_index_range_count(return_type:ListReturnType, index:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects "count" list items starting at specified index
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_rank_range(return_type:ListReturnType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items starting at specified rank to the last ranked item
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_rank_range_count(return_type:ListReturnType, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects "count" list items starting at specified rank and returns
        selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_value_relative_rank_range(return_type:ListReturnType, value:FilterExpression, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items nearest to value and greater by relative rank
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_get_by_value_relative_rank_range_count(return_type:ListReturnType, value:FilterExpression, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects list items nearest to value and greater by relative rank with a count limit
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def list_append(policy:ListPolicy, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that appends value to end of list.
        """
    @staticmethod
    def list_append_items(policy:ListPolicy, list:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that appends list items to end of list.
        """
    @staticmethod
    def list_insert(policy:ListPolicy, index:FilterExpression, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that inserts value to specified index of list.
        """
    @staticmethod
    def list_insert_items(policy:ListPolicy, index:FilterExpression, list:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that inserts each input list item starting at specified index of list.
        """
    @staticmethod
    def list_increment(policy:ListPolicy, index:FilterExpression, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that increments list[index] by value.
        """
    @staticmethod
    def list_set(policy:ListPolicy, index:FilterExpression, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that sets item value at specified index in list.
        """
    @staticmethod
    def list_clear(bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes all items in list.
        """
    @staticmethod
    def list_sort(sort_flags:ListSortFlags, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that sorts list according to sort_flags.
        """
    @staticmethod
    def list_remove_by_value(return_type:ListReturnType, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items identified by value.
        """
    @staticmethod
    def list_remove_by_value_list(return_type:ListReturnType, values:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items identified by values.
        """
    @staticmethod
    def list_remove_by_value_range(return_type:ListReturnType, value_begin:typing.Optional[FilterExpression], value_end:typing.Optional[FilterExpression], bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items identified by value range
        (value_begin inclusive, value_end exclusive).
        """
    @staticmethod
    def list_remove_by_value_relative_rank_range(return_type:ListReturnType, value:FilterExpression, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items nearest to value and greater by relative rank.
        """
    @staticmethod
    def list_remove_by_value_relative_rank_range_count(return_type:ListReturnType, value:FilterExpression, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items nearest to value and greater by relative rank
        with a count limit.
        """
    @staticmethod
    def list_remove_by_index(return_type:ListReturnType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list item identified by index.
        """
    @staticmethod
    def list_remove_by_index_range(return_type:ListReturnType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items starting at specified index to the end of list.
        """
    @staticmethod
    def list_remove_by_index_range_count(return_type:ListReturnType, index:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes "count" list items starting at specified index.
        """
    @staticmethod
    def list_remove_by_rank(return_type:ListReturnType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list item identified by rank.
        """
    @staticmethod
    def list_remove_by_rank_range(return_type:ListReturnType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes list items starting at specified rank to the last ranked item.
        """
    @staticmethod
    def list_remove_by_rank_range_count(return_type:ListReturnType, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes "count" list items starting at specified rank.
        """
    @staticmethod
    def map_size(bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that returns map size.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_key(return_type:MapReturnType, value_type:ExpType, key:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map item identified by key and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_rank(return_type:MapReturnType, value_type:ExpType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map item identified by rank and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_index(return_type:MapReturnType, value_type:ExpType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map item identified by index and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_value(return_type:MapReturnType, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items identified by value and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_value_range(return_type:MapReturnType, value_begin:typing.Optional[FilterExpression], value_end:typing.Optional[FilterExpression], bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items identified by value range (valueBegin inclusive, valueEnd exclusive)
        and returns selected data specified by returnType.
        If valueBegin is None, the range is less than valueEnd. If valueEnd is None, the range is greater than equal to valueBegin.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_value_list(return_type:MapReturnType, values:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items identified by values and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_key_range(return_type:MapReturnType, key_begin:typing.Optional[FilterExpression], key_end:typing.Optional[FilterExpression], bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items identified by key range (keyBegin inclusive, keyEnd exclusive)
        and returns selected data specified by returnType.
        If keyBegin is None, the range is less than keyEnd. If keyEnd is None, the range is greater than equal to keyBegin.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_key_list(return_type:MapReturnType, keys:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items identified by keys and returns selected data
        specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_key_relative_index_range(return_type:MapReturnType, key:FilterExpression, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items nearest to key and greater by index
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_key_relative_index_range_count(return_type:MapReturnType, key:FilterExpression, index:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items nearest to key and greater by index with a count limit
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_value_relative_rank_range(return_type:MapReturnType, value:FilterExpression, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items nearest to value and greater by relative rank
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_value_relative_rank_range_count(return_type:MapReturnType, value:FilterExpression, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items nearest to value and greater by relative rank with a count limit
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_index_range(return_type:MapReturnType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items starting at specified index to the end of map
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_index_range_count(return_type:MapReturnType, index:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects "count" map items starting at specified index
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_rank_range(return_type:MapReturnType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects map items starting at specified rank to the last ranked item
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_get_by_rank_range_count(return_type:MapReturnType, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that selects "count" map items starting at specified rank
        and returns selected data specified by returnType.
        Supports nested CDT operations via optional CTX contexts.
        """
    @staticmethod
    def map_put(policy:MapPolicy, key:FilterExpression, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that writes key/value item to map bin.
        """
    @staticmethod
    def map_put_items(policy:MapPolicy, map:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that writes each map item to map bin.
        """
    @staticmethod
    def map_increment(policy:MapPolicy, key:FilterExpression, incr:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that increments values by incr for all items identified by key.
        """
    @staticmethod
    def map_clear(bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes all items in map.
        """
    @staticmethod
    def map_remove_by_key(return_type:MapReturnType, key:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map item identified by key.
        """
    @staticmethod
    def map_remove_by_key_list(return_type:MapReturnType, keys:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items identified by keys.
        """
    @staticmethod
    def map_remove_by_key_range(return_type:MapReturnType, key_begin:typing.Optional[FilterExpression], key_end:typing.Optional[FilterExpression], bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items identified by key range
        (key_begin inclusive, key_end exclusive).
        """
    @staticmethod
    def map_remove_by_key_relative_index_range(return_type:MapReturnType, key:FilterExpression, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items nearest to key and greater by index.
        """
    @staticmethod
    def map_remove_by_key_relative_index_range_count(return_type:MapReturnType, key:FilterExpression, index:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items nearest to key and greater by index
        with a count limit.
        """
    @staticmethod
    def map_remove_by_value(return_type:MapReturnType, value:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items identified by value.
        """
    @staticmethod
    def map_remove_by_value_list(return_type:MapReturnType, values:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items identified by values.
        """
    @staticmethod
    def map_remove_by_value_range(return_type:MapReturnType, value_begin:typing.Optional[FilterExpression], value_end:typing.Optional[FilterExpression], bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items identified by value range
        (value_begin inclusive, value_end exclusive).
        """
    @staticmethod
    def map_remove_by_value_relative_rank_range(return_type:MapReturnType, value:FilterExpression, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items nearest to value and greater by relative rank.
        """
    @staticmethod
    def map_remove_by_value_relative_rank_range_count(return_type:MapReturnType, value:FilterExpression, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items nearest to value and greater by relative rank
        with a count limit.
        """
    @staticmethod
    def map_remove_by_index(return_type:MapReturnType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map item identified by index.
        """
    @staticmethod
    def map_remove_by_index_range(return_type:MapReturnType, index:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items starting at specified index to the end of map.
        """
    @staticmethod
    def map_remove_by_index_range_count(return_type:MapReturnType, index:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes "count" map items starting at specified index.
        """
    @staticmethod
    def map_remove_by_rank(return_type:MapReturnType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map item identified by rank.
        """
    @staticmethod
    def map_remove_by_rank_range(return_type:MapReturnType, rank:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes map items starting at specified rank to the last ranked item.
        """
    @staticmethod
    def map_remove_by_rank_range_count(return_type:MapReturnType, rank:FilterExpression, count:FilterExpression, bin:FilterExpression, ctx:typing.Sequence[CTX]) -> FilterExpression:
        r"""
        Create expression that removes "count" map items starting at specified rank.
        """
    @staticmethod
    def bit_resize(policy:BitPolicy, byte_size:FilterExpression, resize_flags:BitwiseResizeFlags, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that resizes byte[] to byte_size according to resize_flags
        and returns byte[].
        """
    @staticmethod
    def bit_insert(policy:BitPolicy, byte_offset:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that inserts value bytes into byte[] bin at byte_offset
        and returns byte[].
        """
    @staticmethod
    def bit_remove(policy:BitPolicy, byte_offset:FilterExpression, byte_size:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that removes bytes from byte[] bin at byte_offset for byte_size
        and returns byte[].
        """
    @staticmethod
    def bit_set(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that sets value on byte[] bin at bit_offset for bit_size
        and returns byte[].
        """
    @staticmethod
    def bit_or(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that performs bitwise "or" on value and byte[] bin at bit_offset
        for bit_size and returns byte[].
        """
    @staticmethod
    def bit_xor(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that performs bitwise "xor" on value and byte[] bin at bit_offset
        for bit_size and returns byte[].
        """
    @staticmethod
    def bit_and(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that performs bitwise "and" on value and byte[] bin at bit_offset
        for bit_size and returns byte[].
        """
    @staticmethod
    def bit_not(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that negates byte[] bin starting at bit_offset for bit_size
        and returns byte[].
        """
    @staticmethod
    def bit_lshift(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, shift:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that shifts left byte[] bin starting at bit_offset for bit_size
        and returns byte[].
        """
    @staticmethod
    def bit_rshift(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, shift:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that shifts right byte[] bin starting at bit_offset for bit_size
        and returns byte[].
        """
    @staticmethod
    def bit_add(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, signed:builtins.bool, action:BitwiseOverflowActions, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that adds value to byte[] bin starting at bit_offset for bit_size
        and returns byte[]. BitSize must be <= 64.
        """
    @staticmethod
    def bit_subtract(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, signed:builtins.bool, action:BitwiseOverflowActions, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that subtracts value from byte[] bin starting at bit_offset for bit_size
        and returns byte[]. BitSize must be <= 64.
        """
    @staticmethod
    def bit_set_int(policy:BitPolicy, bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that sets value to byte[] bin starting at bit_offset for bit_size
        and returns byte[]. BitSize must be <= 64.
        """
    @staticmethod
    def bit_get(bit_offset:FilterExpression, bit_size:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns bits from byte[] bin starting at bit_offset for bit_size.
        """
    @staticmethod
    def bit_count(bit_offset:FilterExpression, bit_size:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns integer count of set bits from byte[] bin starting at
        bit_offset for bit_size.
        """
    @staticmethod
    def bit_lscan(bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns integer bit offset of the first specified value bit
        in byte[] bin starting at bit_offset for bit_size.
        """
    @staticmethod
    def bit_rscan(bit_offset:FilterExpression, bit_size:FilterExpression, value:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns integer bit offset of the last specified value bit
        in byte[] bin starting at bit_offset for bit_size.
        """
    @staticmethod
    def bit_get_int(bit_offset:FilterExpression, bit_size:FilterExpression, signed:builtins.bool, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns integer from byte[] bin starting at bit_offset for bit_size.
        Signed indicates if bits should be treated as a signed number.
        """
    @staticmethod
    def hll_init(policy:HLLPolicy, index_bit_count:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that creates a new HLL or resets an existing HLL.
        """
    @staticmethod
    def hll_init_with_min_hash(policy:HLLPolicy, index_bit_count:FilterExpression, min_hash_count:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that creates a new HLL or resets an existing HLL with minhash bits.
        """
    @staticmethod
    def hll_add(policy:HLLPolicy, list:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that adds list values to a HLL set and returns HLL set.
        """
    @staticmethod
    def hll_add_with_index(policy:HLLPolicy, list:FilterExpression, index_bit_count:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that adds values to a HLL set and returns HLL set.
        If HLL bin does not exist, use index_bit_count to create HLL bin.
        """
    @staticmethod
    def hll_add_with_index_and_min_hash(policy:HLLPolicy, list:FilterExpression, index_bit_count:FilterExpression, min_hash_count:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that adds values to a HLL set and returns HLL set.
        If HLL bin does not exist, use index_bit_count and min_hash_count to create HLL set.
        """
    @staticmethod
    def hll_get_count(bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns estimated number of elements in the HLL bin.
        """
    @staticmethod
    def hll_get_union(list:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns a HLL object that is the union of all specified
        HLL objects in the list with the HLL bin.
        """
    @staticmethod
    def hll_get_union_count(list:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns estimated number of elements that would be contained
        by the union of these HLL objects.
        """
    @staticmethod
    def hll_get_intersect_count(list:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns estimated number of elements that would be contained
        by the intersection of these HLL objects.
        """
    @staticmethod
    def hll_get_similarity(list:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns estimated similarity of these HLL objects
        as a 64 bit float.
        """
    @staticmethod
    def hll_describe(bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns index_bit_count and min_hash_bit_count used to create
        HLL bin in a list of longs.
        """
    @staticmethod
    def hll_may_contain(list:FilterExpression, bin:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns one if HLL bin may contain all items in the list.
        """

class HLLPolicy:
    r"""
    HLL policy for HLL operations and expressions.
    """
    def __new__(cls, write_flags:HLLWriteFlags=HLLWriteFlags.DEFAULT) -> HLLPolicy: ...

class ListPolicy:
    @property
    def order(self) -> ListOrderType: ...
    @order.setter
    def order(self, value: ListOrderType) -> None: ...
    @property
    def write_flags(self) -> ListWriteFlags: ...
    @write_flags.setter
    def write_flags(self, value: ListWriteFlags) -> None: ...
    def __new__(cls, order:typing.Optional[ListOrderType], write_flags:typing.Optional[ListWriteFlags]) -> ListPolicy:
        r"""
        Create a new ListPolicy with the specified order and write flags.
        Default is unordered list with default write flags.
        """

class ListReturnType:
    r"""
    List return type for CDT operations.

    Supports bitwise OR for combining with INVERTED flag:
        combined = ListReturnType.VALUE | ListReturnType.INVERTED
    """
    NONE: ListReturnType
    """Do not return a result."""
    INDEX: ListReturnType
    """Return index offset order."""
    REVERSE_INDEX: ListReturnType
    """Return reverse index offset order."""
    RANK: ListReturnType
    """Return value order."""
    REVERSE_RANK: ListReturnType
    """Return reverse value order."""
    COUNT: ListReturnType
    """Return count of items selected."""
    VALUE: ListReturnType
    """Return value for single key read and value list for range read."""
    EXISTS: ListReturnType
    """Return true if count > 0."""
    INVERTED: ListReturnType
    """Invert meaning of list command and return values. Can be OR'd with other return types."""

    def __or__(self, other: ListReturnType) -> ListReturnType:
        """Bitwise OR - allows combining return type with INVERTED flag."""
        ...
    def __and__(self, other: ListReturnType) -> ListReturnType:
        """Bitwise AND."""
        ...
    def __int__(self) -> builtins.int:
        """Convert to integer."""
        ...
    def __eq__(self, other: object) -> builtins.bool: ...
    def __ne__(self, other: object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...

class MapPolicy:
    @property
    def order(self) -> MapOrder: ...
    @order.setter
    def order(self, value: MapOrder) -> None: ...
    @property
    def write_mode(self) -> MapWriteMode: ...
    @write_mode.setter
    def write_mode(self, value: MapWriteMode) -> None: ...
    def __new__(cls, order:typing.Optional[MapOrder], write_mode:typing.Optional[MapWriteMode]) -> MapPolicy:
        r"""
        Create a new MapPolicy with the specified order and write mode.
        Default is unordered map with update write mode.
        """

class MapReturnType:
    r"""
    Map return type for CDT operations.

    Supports bitwise OR for combining with INVERTED flag:
        combined = MapReturnType.VALUE | MapReturnType.INVERTED
    """
    NONE: MapReturnType
    """Do not return a result."""
    INDEX: MapReturnType
    """Return key index order."""
    REVERSE_INDEX: MapReturnType
    """Return reverse key order."""
    RANK: MapReturnType
    """Return value order."""
    REVERSE_RANK: MapReturnType
    """Return reverse value order."""
    COUNT: MapReturnType
    """Return count of items selected."""
    KEY: MapReturnType
    """Return key for single key read and key list for range read."""
    VALUE: MapReturnType
    """Return value for single key read and value list for range read."""
    KEY_VALUE: MapReturnType
    """Return key/value items."""
    EXISTS: MapReturnType
    """Returns true if count > 0."""
    UNORDERED_MAP: MapReturnType
    """Returns an unordered map."""
    ORDERED_MAP: MapReturnType
    """Returns an ordered map."""
    INVERTED: MapReturnType
    """Invert meaning of map command and return values. Can be OR'd with other return types."""

    def __or__(self, other: MapReturnType) -> MapReturnType:
        """Bitwise OR - allows combining return type with INVERTED flag."""
        ...
    def __and__(self, other: MapReturnType) -> MapReturnType:
        """Bitwise AND."""
        ...
    def __int__(self) -> builtins.int:
        """Convert to integer."""
        ...
    def __eq__(self, other: object) -> builtins.bool: ...
    def __ne__(self, other: object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...

class PartitionFilter:
    @property
    def begin(self) -> builtins.int: ...
    @begin.setter
    def begin(self, value: builtins.int) -> None: ...
    @property
    def count(self) -> builtins.int: ...
    @count.setter
    def count(self, value: builtins.int) -> None: ...
    @property
    def digest(self) -> typing.Optional[builtins.str]: ...
    @digest.setter
    def digest(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def partitions(self) -> typing.Any: ...
    @partitions.setter
    def partitions(self, value: typing.Optional[list]) -> None: ...
    def __new__(cls) -> PartitionFilter: ...
    def done(self) -> builtins.bool: ...
    @staticmethod
    def all() -> PartitionFilter: ...
    @staticmethod
    def by_id(id:builtins.int) -> PartitionFilter: ...
    @staticmethod
    def by_key(key:Key) -> PartitionFilter: ...
    @staticmethod
    def by_range(begin:builtins.int, count:builtins.int) -> PartitionFilter: ...

class PartitionStatus:
    @property
    def bval(self) -> typing.Optional[builtins.int]: ...
    @bval.setter
    def bval(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def id(self) -> builtins.int: ...
    @property
    def retry(self) -> builtins.bool: ...
    @retry.setter
    def retry(self, value: builtins.bool) -> None: ...
    @property
    def digest(self) -> typing.Optional[builtins.str]: ...
    @digest.setter
    def digest(self, value: typing.Optional[builtins.str]) -> None: ...
    def __new__(cls, id:builtins.int) -> PartitionStatus:
        r"""
        Create a new PartitionStatus with the specified partition ID.

        The `retry` field defaults to `true`, and other fields can be set via setters.
        """
    def __getitem__(self, key:typing.Any) -> typing.Any:
        r"""
        Dictionary-style access for convenience (in addition to getters/setters).
        Supported keys: 'id', 'bval', 'retry', 'digest'
        Example: ps['id'], ps['bval'] = 123
        """
    def __setitem__(self, key:typing.Any, value:typing.Any) -> None:
        r"""
        Dictionary-style assignment for convenience (in addition to getters/setters).
        Supported keys: 'bval', 'retry', 'digest'
        Note: 'id' is read-only and cannot be set.
        """

class Privilege:
    @property
    def code(self) -> PrivilegeCode: ...
    @property
    def namespace(self) -> typing.Optional[builtins.str]: ...
    @property
    def set_name(self) -> typing.Optional[str]: ...
    def __new__(cls, code:PrivilegeCode, namespace:typing.Optional[builtins.str], set_name:typing.Optional[builtins.str]) -> Privilege: ...
    def as_string(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class QueryPolicy(BasePolicy):
    def __new__(cls) -> QueryPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def records_per_second(self) -> builtins.int: ...
    @records_per_second.setter
    def records_per_second(self, value: builtins.int) -> None: ...
    @property
    def max_records(self) -> builtins.int: ...
    @max_records.setter
    def max_records(self, value: builtins.int) -> None: ...
    @property
    def expected_duration(self) -> QueryDuration: ...
    @expected_duration.setter
    def expected_duration(self, value: QueryDuration) -> None: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...

class ReadPolicy(BasePolicy):
    def __new__(cls) -> ReadPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...

class Recordset:
    r"""
    Virtual collection of records retrieved through queries and scans. During a query/scan,
    multiple threads will retrieve records from the server nodes and put these records on an
    internal queue managed by the recordset. The single user thread consumes these records from the
    queue.
    """
    @property
    def active(self) -> builtins.bool: ...
    def close(self) -> None: ...
    def partition_filter(self) -> typing.Awaitable[typing.Optional[PartitionFilter]]: ...
    def __aiter__(self) -> Recordset: ...
    def __anext__(self) -> typing.Any: ...

class ResultCode:
    OK: ResultCode
    SERVER_ERROR: ResultCode
    KEY_NOT_FOUND_ERROR: ResultCode
    GENERATION_ERROR: ResultCode
    PARAMETER_ERROR: ResultCode
    KEY_EXISTS_ERROR: ResultCode
    BIN_EXISTS_ERROR: ResultCode
    CLUSTER_KEY_MISMATCH: ResultCode
    SERVER_MEM_ERROR: ResultCode
    TIMEOUT: ResultCode
    ALWAYS_FORBIDDEN: ResultCode
    PARTITION_UNAVAILABLE: ResultCode
    BIN_TYPE_ERROR: ResultCode
    RECORD_TOO_BIG: ResultCode
    KEY_BUSY: ResultCode
    SCAN_ABORT: ResultCode
    UNSUPPORTED_FEATURE: ResultCode
    BIN_NOT_FOUND: ResultCode
    DEVICE_OVERLOAD: ResultCode
    KEY_MISMATCH: ResultCode
    INVALID_NAMESPACE: ResultCode
    BIN_NAME_TOO_LONG: ResultCode
    FAIL_FORBIDDEN: ResultCode
    ELEMENT_NOT_FOUND: ResultCode
    ELEMENT_EXISTS: ResultCode
    ENTERPRISE_ONLY: ResultCode
    OP_NOT_APPLICABLE: ResultCode
    FILTERED_OUT: ResultCode
    LOST_CONFLICT: ResultCode
    XDR_KEY_BUSY: ResultCode
    QUERY_END: ResultCode
    SECURITY_NOT_SUPPORTED: ResultCode
    SECURITY_NOT_ENABLED: ResultCode
    NOT_AUTHENTICATED: ResultCode
    SECURITY_SCHEME_NOT_SUPPORTED: ResultCode
    INVALID_COMMAND: ResultCode
    INVALID_FIELD: ResultCode
    ILLEGAL_STATE: ResultCode
    INVALID_USER: ResultCode
    USER_ALREADY_EXISTS: ResultCode
    FORBIDDEN_PASSWORD: ResultCode
    UDF_BAD_RESPONSE: ResultCode
    INDEX_FOUND: ResultCode
    INDEX_NOT_FOUND: ResultCode
    INDEX_OOM: ResultCode
    INDEX_NOT_READABLE: ResultCode
    INDEX_GENERIC: ResultCode
    INDEX_NAME_MAX_LEN: ResultCode
    INDEX_MAX_COUNT: ResultCode
    QUERY_ABORTED: ResultCode
    QUERY_QUEUE_FULL: ResultCode
    QUERY_TIMEOUT: ResultCode
    QUERY_GENERIC: ResultCode
    def __richcmp__(self, other:ResultCode, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...

class Statement:
    r"""
    Query statement parameters.
    """
    @property
    def index_name(self) -> typing.Optional[builtins.str]: ...
    @index_name.setter
    def index_name(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def filters(self) -> typing.Optional[builtins.list[Filter]]: ...
    @filters.setter
    def filters(self, value: typing.Optional[builtins.list[Filter]]) -> None: ...
    @property
    def set_name(self) -> typing.Optional[str]: ...
    @set_name.setter
    def set_name(self, value: typing.Optional[str]) -> None: ...
    def __new__(cls, namespace:builtins.str, set_name:typing.Optional[str] = None, bins:typing.Optional[typing.Sequence[builtins.str]]=None, index_name:typing.Optional[builtins.str]=None) -> Statement: ...
    def set_aggregate_function(self, package_name:builtins.str, function_name:builtins.str, function_args:typing.Optional[typing.Sequence[typing.Any]]=None) -> None:
        r"""
        Set Lua aggregation function parameters for query aggregation.

        Args:
            package_name: Name of the Lua package/module containing the aggregation function.
            function_name: Name of the Lua aggregation function.
            function_args: Optional list of arguments to pass to the function.
        """

class WritePolicy(BasePolicy):
    def __new__(cls) -> WritePolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def record_exists_action(self) -> RecordExistsAction: ...
    @record_exists_action.setter
    def record_exists_action(self, value: RecordExistsAction) -> None: ...
    @property
    def generation_policy(self) -> GenerationPolicy: ...
    @generation_policy.setter
    def generation_policy(self, value: GenerationPolicy) -> None: ...
    @property
    def commit_level(self) -> CommitLevel: ...
    @commit_level.setter
    def commit_level(self, value: CommitLevel) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...

class AuthMode(Enum):
    r"""
    Authentication mode for client connections.
    """
    NONE = ...
    r"""
    No authentication will be performed.
    """
    INTERNAL = ...
    r"""
    Uses internal authentication when user/password defined. Hashed password is stored
    on the server. Do not send clear password. This is the default.
    """
    EXTERNAL = ...
    r"""
    Uses external authentication (like LDAP) when user/password defined. Specific external
    authentication is configured on server. If TLSConfig is defined, sends clear password
    on node login via TLS. Will return an error if TLSConfig is not defined.
    """
    PKI = ...
    r"""
    Allows authentication and authorization based on a certificate. No user name or
    password needs to be configured. Requires TLS and a client certificate.
    Requires server version 5.7.0+
    """

class BitwiseOverflowActions(Enum):
    FAIL = ...
    SATURATE = ...
    WRAP = ...

class BitwiseResizeFlags(Enum):
    DEFAULT = ...
    FROM_FRONT = ...
    GROW_ONLY = ...
    SHRINK_ONLY = ...

class BitwiseWriteFlags(Enum):
    DEFAULT = ...
    CREATE_ONLY = ...
    UPDATE_ONLY = ...
    NO_FAIL = ...
    PARTIAL = ...

class CollectionIndexType(Enum):
    r"""
    Secondary index collection type.
    """
    DEFAULT = ...
    LIST = ...
    MAP_KEYS = ...
    MAP_VALUES = ...

class CommitLevel(Enum):
    COMMIT_ALL = ...
    COMMIT_MASTER = ...

class ConsistencyLevel(Enum):
    CONSISTENCY_ONE = ...
    CONSISTENCY_ALL = ...

class ExpReadFlags(Enum):
    r"""
    Expression read flags for expression operations.
    """
    DEFAULT = ...
    r"""
    Default.
    """
    EVAL_NO_FAIL = ...
    r"""
    Ignore failures caused by the expression resolving to unknown or a non-bin type.
    """

class ExpType(Enum):
    r"""
    Expression Data Types for usage in some `FilterExpressions`
    """
    NIL = ...
    BOOL = ...
    INT = ...
    STRING = ...
    LIST = ...
    MAP = ...
    BLOB = ...
    FLOAT = ...
    GEO = ...
    HLL = ...

class ExpWriteFlags(Enum):
    r"""
    Expression write flags for expression operations.
    """
    DEFAULT = ...
    r"""
    Default. Allow create or update.
    """
    CREATE_ONLY = ...
    r"""
    If bin does not exist, a new bin will be created.
    If bin exists, the operation will be denied.
    """
    UPDATE_ONLY = ...
    r"""
    If bin exists, the bin will be overwritten.
    If bin does not exist, the operation will be denied.
    """
    ALLOW_DELETE = ...
    r"""
    If expression results in nil value, then delete the bin.
    """
    POLICY_NO_FAIL = ...
    r"""
    Do not raise error if operation is denied.
    """
    EVAL_NO_FAIL = ...
    r"""
    Ignore failures caused by the expression resolving to unknown or a non-bin type.
    """

class GenerationPolicy(Enum):
    NONE = ...
    EXPECT_GEN_EQUAL = ...
    EXPECT_GEN_GREATER = ...

class HLLWriteFlags(Enum):
    r"""
    HLL write flags for HLL operations.
    """
    DEFAULT = ...
    r"""
    Default. Allow create or update.
    """
    CREATE_ONLY = ...
    r"""
    If the bin already exists, the operation will be denied.
    If the bin does not exist, a new bin will be created.
    """
    UPDATE_ONLY = ...
    r"""
    If the bin already exists, the bin will be overwritten.
    If the bin does not exist, the operation will be denied.
    """
    NO_FAIL = ...
    r"""
    Do not raise error if operation is denied.
    """
    ALLOW_FOLD = ...
    r"""
    Allow the resulting set to be the minimum of provided index bits.
    """

class IndexType(Enum):
    r"""
    Underlying data type of secondary index.
    """
    NUMERIC = ...
    STRING = ...
    GEO2D_SPHERE = ...

class ListOrderType(Enum):
    UNORDERED = ...
    r"""
    List is not ordered. This is the default.
    """
    ORDERED = ...
    r"""
    List is ordered.
    """

class ListSortFlags(Enum):
    DEFAULT = ...
    r"""
    Default. Preserve duplicate values when sorting list.
    """
    DESCENDING = ...
    r"""
    Sort in descending order.
    """
    DROP_DUPLICATES = ...
    r"""
    Drop duplicate values when sorting list.
    """

class ListWriteFlags(Enum):
    DEFAULT = ...
    r"""
    Default is the default behavior. It means: Allow duplicate values and insertions at any index.
    """
    ADD_UNIQUE = ...
    r"""
    AddUnique means: Only add unique values.
    """
    INSERT_BOUNDED = ...
    r"""
    InsertBounded means: Enforce list boundaries when inserting. Do not allow values to be inserted at index outside current list boundaries.
    """
    NO_FAIL = ...
    r"""
    NoFail means: do not raise error if a list item fails due to write flag constraints.
    """
    PARTIAL = ...
    r"""
    Partial means: allow other valid list items to be committed if a list item fails due to write flag constraints.
    """

class MapOrder(Enum):
    UNORDERED = ...
    r"""
    Map is not ordered. This is the default.
    """
    KEY_ORDERED = ...
    r"""
    Order map by key.
    """
    KEY_VALUE_ORDERED = ...
    r"""
    Order map by key, then value.
    """

class MapWriteMode(Enum):
    UPDATE = ...
    r"""
    If the key already exists, the item will be overwritten.
    If the key does not exist, a new item will be created.
    """
    UPDATE_ONLY = ...
    r"""
    If the key already exists, the item will be overwritten.
    If the key does not exist, the write will fail.
    """
    CREATE_ONLY = ...
    r"""
    If the key already exists, the write will fail.
    If the key does not exist, a new item will be created.
    """

class PrivilegeCode(Enum):
    r"""
    Secondary index collection type.
    """
    UserAdmin = ...
    r"""
    User can edit/remove other users.  Global scope only.
    """
    SysAdmin = ...
    r"""
    User can perform systems administration functions on a database that do not involve user
    administration.  Examples include server configuration.
    Global scope only.
    """
    DataAdmin = ...
    r"""
    User can perform UDF and SINDEX administration actions. Global scope only.
    """
    UDFAdmin = ...
    r"""
    User can perform user defined function(UDF) administration actions.
    Examples include create/drop UDF. Global scope only.
    Requires server version 6+
    """
    SIndexAdmin = ...
    r"""
    User can perform secondary index administration actions.
    Examples include create/drop index. Global scope only.
    Requires server version 6+
    """
    Read = ...
    r"""
    User can read data only.
    """
    ReadWrite = ...
    r"""
    User can read and write data.
    """
    ReadWriteUDF = ...
    r"""
    User can read and write data through user defined functions.
    """
    Write = ...
    r"""
    User can read and write data through user defined functions.
    """
    Truncate = ...
    r"""
    User can truncate data only.
    Requires server version 6+
    """
    MaskingAdmin = ...
    r"""
    User can perform data masking administration actions.
    Global scope only.
    """
    ReadMasked = ...
    r"""
    User can read masked data only.
    """
    WriteMasked = ...
    r"""
    User can write masked data only.
    """

class QueryDuration(Enum):
    r"""
    Expected query duration. The server treats the query in different ways depending on the expected duration.
    This enum is ignored for aggregation queries, background queries and server versions < 6.0.
    """
    LONG = ...
    r"""
    Long specifies that the query is expected to return more than 100 records per node.
    """
    SHORT = ...
    r"""
    Short specifies that the query is expected to return less than 100 records per node.
    """
    LONG_RELAX_AP = ...
    r"""
    LongRelaxAP will treat query as a Long query, but relax read consistency for AP namespaces.
    """

class RecordExistsAction(Enum):
    r"""
    `RecordExistsAction` determines how to handle record writes based on record generation.
    """
    UPDATE = ...
    UPDATE_ONLY = ...
    REPLACE = ...
    REPLACE_ONLY = ...
    CREATE_ONLY = ...

class Replica(Enum):
    r"""
    Priority of operations on database server.
    """
    MASTER = ...
    SEQUENCE = ...
    PREFER_RACK = ...

class TaskStatus(Enum):
    NOT_FOUND = ...
    IN_PROGRESS = ...
    COMPLETE = ...

class UDFLang(Enum):
    r"""
    User-defined function (UDF) language.
    """
    LUA = ...
    r"""
    Lua embedded programming language.
    """

def geojson(geo_str:builtins.str) -> GeoJSON:
    r"""
    Convert a GeoJSON string or coordinate pair to a GeoJSON object.
    This matches the legacy client's aerospike.geojson() function.

    Accepts:
    - GeoJSON JSON string: '{"type": "Point", "coordinates": [-122.0, 37.0]}'
    - Coordinate pair string: "-122.0, 37.5" (longitude, latitude)
    """

class Record:
    r"""
    Aerospike record returned from get() and operate() operations.
    """
    def bin(self, name: builtins.str) -> typing.Optional[typing.Any]: ...
    @property
    def bins(self) -> typing.Dict[builtins.str, typing.Any]: ...
    @property
    def generation(self) -> typing.Optional[builtins.int]: ...
    @property
    def ttl(self) -> typing.Optional[builtins.int]: ...
    @property
    def key(self) -> typing.Optional[Key]: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Key:
    r"""
    Aerospike record key. Create keys using Key(namespace, set, key) or Key.key_with_digest().
    """
    def __new__(cls, namespace: builtins.str, set: builtins.str, key: typing.Any) -> Key: ...
    @property
    def namespace(self) -> builtins.str: ...
    @property
    def set_name(self) -> builtins.str: ...
    @property
    def value(self) -> typing.Optional[typing.Any]: ...
    @property
    def digest(self) -> typing.Optional[builtins.str]: ...
    @staticmethod
    def key_with_digest(namespace: builtins.str, set: builtins.str, digest: typing.Union[builtins.bytes, builtins.str]) -> Key: ...

class Operation:
    r"""
    Basic bin operations. Create operations used by the client's operate() method.
    """
    def __new__(cls) -> Operation: ...
    @staticmethod
    def new() -> Operation: ...
    @staticmethod
    def get() -> Operation: ...
    @staticmethod
    def get_bin(bin_name: builtins.str) -> Operation: ...
    @staticmethod
    def put(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    @staticmethod
    def get_header() -> Operation: ...
    @staticmethod
    def delete() -> Operation: ...
    @staticmethod
    def touch() -> Operation: ...
    @staticmethod
    def add(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    @staticmethod
    def append(bin_name: builtins.str, value: typing.Any) -> Operation: ...
    @staticmethod
    def prepend(bin_name: builtins.str, value: typing.Any) -> Operation: ...

class ListOperation:
    r"""
    List bin operations. Create list operations used by the client's operate() method.
    """
    def __new__(cls) -> ListOperation: ...
    def set_context(self, ctx: typing.Sequence[CTX]) -> ListOperation: ...
    @staticmethod
    def get(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def size(bin_name: builtins.str) -> ListOperation: ...
    @staticmethod
    def pop(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def clear(bin_name: builtins.str) -> ListOperation: ...
    @staticmethod
    def get_range(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def set(bin_name: builtins.str, index: builtins.int, value: typing.Any) -> ListOperation: ...
    @staticmethod
    def remove(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def remove_range(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def get_range_from(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def pop_range(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def pop_range_from(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def remove_range_from(bin_name: builtins.str, index: builtins.int) -> ListOperation: ...
    @staticmethod
    def trim(bin_name: builtins.str, index: builtins.int, count: builtins.int) -> ListOperation: ...
    @staticmethod
    def append(bin_name: builtins.str, value: typing.Any, policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def append_items(bin_name: builtins.str, values: typing.Sequence[typing.Any], policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def insert(bin_name: builtins.str, index: builtins.int, value: typing.Any, policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def insert_items(bin_name: builtins.str, index: builtins.int, values: typing.Sequence[typing.Any], policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def increment(bin_name: builtins.str, index: builtins.int, value: builtins.int, policy: ListPolicy) -> ListOperation: ...
    @staticmethod
    def sort(bin_name: builtins.str, flags: ListSortFlags) -> ListOperation: ...
    @staticmethod
    def set_order(bin_name: builtins.str, order: ListOrderType) -> ListOperation: ...
    @staticmethod
    def get_by_index(bin_name: builtins.str, index: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_index_range(bin_name: builtins.str, index: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value(bin_name: builtins.str, value: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def get_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_index(bin_name: builtins.str, index: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_index_range(bin_name: builtins.str, index: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value(bin_name: builtins.str, value: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def remove_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: ListReturnType) -> ListOperation: ...
    @staticmethod
    def create(bin_name: builtins.str, order: ListOrderType, pad: builtins.bool, persist_index: builtins.bool) -> ListOperation: ...

class MapOperation:
    r"""
    Map bin operations. Create map operations used by the client's operate() method.
    """
    def __new__(cls) -> MapOperation: ...
    def set_context(self, ctx: typing.Sequence[CTX]) -> MapOperation: ...
    @staticmethod
    def size(bin_name: builtins.str) -> MapOperation: ...
    @staticmethod
    def clear(bin_name: builtins.str) -> MapOperation: ...
    @staticmethod
    def put(bin_name: builtins.str, key: typing.Any, value: typing.Any, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def put_items(bin_name: builtins.str, items: typing.Sequence[typing.Tuple[typing.Any, typing.Any]], policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def increment_value(bin_name: builtins.str, key: typing.Any, value: builtins.int, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def decrement_value(bin_name: builtins.str, key: typing.Any, value: builtins.int, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def get_by_key(bin_name: builtins.str, key: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key(bin_name: builtins.str, key: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_key_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_index(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_index(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_index_range(bin_name: builtins.str, index: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_index_range(bin_name: builtins.str, index: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_index_range_from(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_index_range_from(bin_name: builtins.str, index: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_rank(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_rank_range(bin_name: builtins.str, rank: builtins.int, count: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_rank_range_from(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_rank_range_from(bin_name: builtins.str, rank: builtins.int, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value(bin_name: builtins.str, value: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value(bin_name: builtins.str, value: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value_range(bin_name: builtins.str, begin: typing.Any, end: typing.Any, return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_key_list(bin_name: builtins.str, keys: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key_list(bin_name: builtins.str, keys: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value_list(bin_name: builtins.str, values: typing.Sequence[typing.Any], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def set_map_policy(bin_name: builtins.str, policy: MapPolicy) -> MapOperation: ...
    @staticmethod
    def get_by_key_relative_index_range(bin_name: builtins.str, key: typing.Any, index: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def get_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_key_relative_index_range(bin_name: builtins.str, key: typing.Any, index: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def remove_by_value_relative_rank_range(bin_name: builtins.str, value: typing.Any, rank: builtins.int, count: typing.Optional[builtins.int], return_type: MapReturnType) -> MapOperation: ...
    @staticmethod
    def create(bin_name: builtins.str, order: MapOrder) -> MapOperation: ...

class BitOperation:
    r"""
    Bit operations. Create bit operations used by the client's operate() method.
    """
    def __new__(cls) -> BitOperation: ...
    @staticmethod
    def resize(bin_name: builtins.str, byte_size: builtins.int, resize_flags: typing.Optional[BitwiseResizeFlags], policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def insert(bin_name: builtins.str, byte_offset: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def remove(bin_name: builtins.str, byte_offset: builtins.int, byte_size: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def set(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def or(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def xor(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def and(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: typing.Any, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def not(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def lshift(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, shift: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def rshift(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, shift: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def add(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.int, signed: builtins.bool, action: BitwiseOverflowActions, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def subtract(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.int, signed: builtins.bool, action: BitwiseOverflowActions, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def set_int(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.int, policy: BitPolicy) -> BitOperation: ...
    @staticmethod
    def get(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int) -> BitOperation: ...
    @staticmethod
    def count(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int) -> BitOperation: ...
    @staticmethod
    def lscan(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.bool) -> BitOperation: ...
    @staticmethod
    def rscan(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, value: builtins.bool) -> BitOperation: ...
    @staticmethod
    def get_int(bin_name: builtins.str, bit_offset: builtins.int, bit_size: builtins.int, signed: builtins.bool) -> BitOperation: ...

class ExpOperation:
    r"""
    Expression operations. Create expression operations used by the client's operate() method.
    """
    @staticmethod
    def read(name: builtins.str, exp: FilterExpression, flags: builtins.int = 0) -> ExpOperation:
        r"""
        Evaluate the expression and return the result in the record bins with the specified name.
        """
        ...
    @staticmethod
    def write(bin_name: builtins.str, exp: FilterExpression, flags: builtins.int = 0) -> ExpOperation:
        r"""
        Evaluate the expression and write the result to the specified bin.
        """
        ...

class IndexTask:
    r"""
    Task returned by create_index_using_expression() to track index creation status.
    """
    def query_status(self) -> typing.Awaitable[TaskStatus]: ...
    def wait_till_complete(self, sleep_time: builtins.float = 0.25, max_attempts: builtins.int = 80) -> typing.Awaitable[builtins.bool]: ...

class DropIndexTask:
    r"""
    Task returned by drop_index() to track index deletion status.
    """
    def query_status(self) -> typing.Awaitable[TaskStatus]: ...
    def wait_till_complete(self, sleep_time: builtins.float = 0.25, max_attempts: builtins.int = 80) -> typing.Awaitable[builtins.bool]: ...

class Node:
    r"""
    Cluster node returned by get_node() or nodes(). Provides node info and server version.
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def address(self) -> builtins.str: ...
    @property
    def is_active(self) -> builtins.bool: ...
    @property
    def version(self) -> Version: ...
    @property
    def host(self) -> typing.Tuple[builtins.str, builtins.int]: ...
    @property
    def failures(self) -> builtins.int: ...
    @property
    def partition_generation(self) -> builtins.int: ...
    @property
    def rebalance_generation(self) -> builtins.int: ...
    def aliases(self) -> typing.Awaitable[typing.List[typing.Tuple[builtins.str, builtins.int]]]: ...
    def info(self, command: builtins.str, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[typing.Dict[builtins.str, builtins.str]]: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Client:
    r"""
    Aerospike async client for database operations.
    Create instances using new_client() function.
    """
    def seeds(self) -> builtins.str: ...
    def close(self) -> typing.Awaitable[typing.Any]: ...
    def is_connected(self) -> typing.Awaitable[builtins.bool]: ...
    def put(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def get(self, policy: ReadPolicy, key: Key, bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Any]: ...
    def add(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def append(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def prepend(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def delete(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def touch(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists_legacy(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Tuple[Key, typing.Optional[typing.Any]]]: ...
    def truncate(self, namespace: builtins.str, set_name: builtins.str, before_nanos: typing.Optional[builtins.int] = None) -> typing.Awaitable[typing.Any]: ...
    def create_index(self, namespace: builtins.str, set_name: builtins.str, bin_name: builtins.str, index_name: builtins.str, index_type: IndexType, cit: typing.Optional[CollectionIndexType] = None) -> typing.Awaitable[typing.Any]: ...
    def create_index_using_expression(self, namespace: builtins.str, set_name: builtins.str, index_name: builtins.str, index_type: IndexType, expression: FilterExpression, cit: typing.Optional[CollectionIndexType] = None, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[IndexTask]: ...
    def drop_index(self, namespace: builtins.str, set_name: builtins.str, index_name: builtins.str, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[DropIndexTask]: ...
    def query(self, policy: QueryPolicy, partition_filter: PartitionFilter, statement: Statement) -> typing.Awaitable[typing.Any]: ...
    def operate(self, policy: WritePolicy, key: Key, operations: typing.Sequence[typing.Union[Operation, ListOperation, MapOperation, BitOperation, HllOperation, ExpOperation]]) -> typing.Awaitable[Record]: ...
    def execute_udf(self, policy: WritePolicy, key: Key, server_path: builtins.str, function_name: builtins.str, args: typing.Optional[typing.Sequence[typing.Any]] = None) -> typing.Awaitable[typing.Optional[typing.Any]]: ...
    def register_udf(self, udf_body: builtins.bytes, server_path: builtins.str, language: UDFLang, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[RegisterTask]: ...
    def register_udf_from_file(self, client_path: builtins.str, server_path: builtins.str, language: UDFLang, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[RegisterTask]: ...
    def remove_udf(self, server_path: builtins.str, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[UdfRemoveTask]: ...
    def batch_read(self, batch_policy: typing.Optional[BatchPolicy], read_policy: typing.Optional[BatchReadPolicy], keys: typing.Sequence[Key], bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_write(self, batch_policy: typing.Optional[BatchPolicy], write_policy: typing.Optional[BatchWritePolicy], keys: typing.Sequence[Key], bins_list: typing.Sequence[typing.Dict[builtins.str, typing.Any]]) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_operate(self, batch_policy: typing.Optional[BatchPolicy], write_policy: typing.Optional[BatchWritePolicy], keys: typing.Sequence[Key], operations_list: typing.Sequence[typing.Sequence[typing.Union[Operation, ListOperation, MapOperation, BitOperation, HllOperation, ExpOperation]]]) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_delete(self, batch_policy: typing.Optional[BatchPolicy], delete_policy: typing.Optional[BatchDeletePolicy], keys: typing.Sequence[Key]) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_apply(self, batch_policy: typing.Optional[BatchPolicy], udf_policy: typing.Optional[BatchUDFPolicy], keys: typing.Sequence[Key], udf_name: builtins.str, function_name: builtins.str, args: typing.Optional[typing.Sequence[typing.Any]] = None) -> typing.Awaitable[typing.Sequence[BatchRecord]]: ...
    def batch_exists(self, batch_policy: typing.Optional[BatchPolicy], read_policy: typing.Optional[BatchReadPolicy], keys: typing.Sequence[Key]) -> typing.Awaitable[typing.Sequence[builtins.bool]]: ...
    def batch_get_header(self, batch_policy: typing.Optional[BatchPolicy], read_policy: typing.Optional[BatchReadPolicy], keys: typing.Sequence[Key]) -> typing.Awaitable[typing.Sequence[typing.Optional[Record]]]: ...
    def node_names(self) -> typing.Awaitable[typing.List[builtins.str]]: ...
    def get_node(self, name: builtins.str) -> typing.Awaitable[Node]: ...
    def nodes(self) -> typing.Awaitable[typing.List[Node]]: ...
    def info(self, command: builtins.str) -> typing.Awaitable[typing.Dict[builtins.str, builtins.str]]: ...
    def info_on_all_nodes(self, command: builtins.str) -> typing.Awaitable[typing.Dict[builtins.str, typing.Dict[builtins.str, builtins.str]]]: ...
    def create_user(self, user: builtins.str, password: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def create_pki_user(self, user: builtins.str, roles: typing.Sequence[builtins.str], *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[typing.Any]: ...
    def drop_user(self, user: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def change_password(self, user: builtins.str, password: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def grant_roles(self, user: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def revoke_roles(self, user: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def query_users(self, user: typing.Optional[builtins.str] = None) -> typing.Awaitable[typing.Sequence[User]]: ...
    def query_roles(self, role: typing.Optional[builtins.str] = None) -> typing.Awaitable[typing.Sequence[Role]]: ...
    def create_role(self, role_name: builtins.str, privileges: typing.Sequence[Privilege], allowlist: typing.Sequence[builtins.str], read_quota: builtins.int, write_quota: builtins.int) -> typing.Awaitable[typing.Any]: ...
    def drop_role(self, role_name: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def grant_privileges(self, role_name: builtins.str, privileges: typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]: ...
    def revoke_privileges(self, role_name: builtins.str, privileges: typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]: ...
    def set_allowlist(self, role_name: builtins.str, allowlist: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def set_quotas(self, role_name: builtins.str, read_quota: builtins.int, write_quota: builtins.int) -> typing.Awaitable[typing.Any]: ...
    def set_xdr_filter(self, datacenter: builtins.str, namespace: builtins.str, filter_expression: typing.Optional[FilterExpression] = None, *, policy: typing.Optional[AdminPolicy] = None) -> typing.Awaitable[typing.Any]: ...

def new_client(policy:ClientPolicy, seeds:builtins.str) -> typing.Awaitable[Client]: ...

def null() -> typing.Any:
    r"""
    Return a null value for use in Aerospike operations.
    This is equivalent to Python None but represents an Aerospike null value.
    Matches the legacy client's aerospike.null() function.
    """


class HllOperation:
    r"""
    HLL (HyperLogLog) operations. Create HLL operations used by the client's operate() method.
    """
    @staticmethod
    def init(bin_name: builtins.str, index_bit_count: builtins.int, min_hash_bit_count: builtins.int = -1, flags: builtins.int = 0) -> HllOperation: ...
    @staticmethod
    def add(bin_name: builtins.str, values: typing.List[typing.Any], index_bit_count: builtins.int = -1, min_hash_bit_count: builtins.int = -1, flags: builtins.int = 0) -> HllOperation: ...
    @staticmethod
    def get_count(bin_name: builtins.str) -> HllOperation: ...
    @staticmethod
    def describe(bin_name: builtins.str) -> HllOperation: ...
    @staticmethod
    def refresh_count(bin_name: builtins.str) -> HllOperation: ...
    @staticmethod
    def fold(bin_name: builtins.str, index_bit_count: builtins.int) -> HllOperation: ...
    @staticmethod
    def get_union(bin_name: builtins.str, hll_list: typing.List[typing.Any]) -> HllOperation: ...
    @staticmethod
    def get_union_count(bin_name: builtins.str, hll_list: typing.List[typing.Any]) -> HllOperation: ...
    @staticmethod
    def get_intersect_count(bin_name: builtins.str, hll_list: typing.List[typing.Any]) -> HllOperation: ...
    @staticmethod
    def get_similarity(bin_name: builtins.str, hll_list: typing.List[typing.Any]) -> HllOperation: ...
    @staticmethod
    def set_union(bin_name: builtins.str, hll_list: typing.List[typing.Any], flags: builtins.int = 0) -> HllOperation: ...

class Version:
    r"""
    Server version information with feature detection methods.
    """
    @property
    def major(self) -> builtins.int: ...
    @property
    def minor(self) -> builtins.int: ...
    @property
    def patch(self) -> builtins.int: ...
    @property
    def build(self) -> builtins.int: ...
    def supports_partition_scan(self) -> builtins.bool: ...
    def supports_query_show(self) -> builtins.bool: ...
    def supports_batch_any(self) -> builtins.bool: ...
    def supports_partition_query(self) -> builtins.bool: ...
    def supports_app_id(self) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
