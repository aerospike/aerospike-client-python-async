# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from ._aerospike_async_native import GeoJSON, Key
from enum import Enum

class BasePolicy:
    @property
    def consistency_level(self) -> ConsistencyLevel: ...
    @consistency_level.setter
    def consistency_level(self, value: ConsistencyLevel) -> None: ...
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    @property
    def max_retries(self) -> typing.Optional[builtins.int]: ...
    @max_retries.setter
    def max_retries(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def sleep_between_retries(self) -> builtins.int: ...
    @sleep_between_retries.setter
    def sleep_between_retries(self, value: builtins.int) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    def __new__(cls) -> BasePolicy: ...

class ClientPolicy:
    @property
    def user(self) -> typing.Optional[builtins.str]: ...
    @user.setter
    def user(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def password(self) -> typing.Optional[builtins.str]: ...
    @password.setter
    def password(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    @property
    def idle_timeout(self) -> builtins.int:
        r"""
        Connection idle timeout. Every time a connection is used, its idle
        deadline will be extended by this duration. When this deadline is reached,
        the connection will be closed and discarded from the connection pool.
        """
    @idle_timeout.setter
    def idle_timeout(self, value: builtins.int) -> None: ...
    @property
    def max_conns_per_node(self) -> builtins.int: ...
    @max_conns_per_node.setter
    def max_conns_per_node(self, value: builtins.int) -> None: ...
    @property
    def conn_pools_per_node(self) -> builtins.int:
        r"""
        Number of connection pools used for each node. Machines with 8 CPU cores or less usually
        need only one connection pool per node. Machines with larger number of CPU cores may have
        their performance limited by contention for pooled connections. Contention for pooled
        connections can be reduced by creating multiple mini connection pools per node.
        """
    @conn_pools_per_node.setter
    def conn_pools_per_node(self, value: builtins.int) -> None: ...
    @property
    def use_services_alternate(self) -> builtins.bool:
        r"""
        UseServicesAlternate determines if the client should use "services-alternate"
        instead of "services" in info request during cluster tending.
        "services-alternate" returns server configured external IP addresses that client
        uses to talk to nodes.  "services-alternate" can be used in place of
        providing a client "ipMap".
        This feature is recommended instead of using the client-side IpMap above.

        "services-alternate" is available with Aerospike Server versions >= 3.7.1.
        """
    @use_services_alternate.setter
    def use_services_alternate(self, value: builtins.bool) -> None: ...
    @property
    def rack_ids(self) -> typing.Optional[builtins.list[builtins.int]]:
        r"""
        Mark this client as belonging to a rack, and track server rack data.  This field is useful when directing read commands to 
        the server node that contains the key and exists on the same rack as the client.
        This serves to lower cloud provider costs when nodes are distributed across different
        racks/data centers.

        Replica.PreferRack and server rack configuration must
        also be set to enable this functionality.
        """
    @rack_ids.setter
    def rack_ids(self, value: typing.Optional[builtins.list[builtins.int]]) -> None: ...
    @property
    def fail_if_not_connected(self) -> builtins.bool:
        r"""
        Size of the thread pool used in scan and query commands. These commands are often sent to
        multiple server nodes in parallel threads. A thread pool improves performance because
        threads do not have to be created/destroyed for each command.
        Throw exception if host connection fails during addHost().
        """
    @fail_if_not_connected.setter
    def fail_if_not_connected(self, value: builtins.bool) -> None: ...
    @property
    def buffer_reclaim_threshold(self) -> builtins.int:
        r"""
        Threshold at which the buffer attached to the connection will be shrunk by deallocating
        memory instead of just resetting the size of the underlying vec.
        Should be set to a value that covers as large a percentile of payload sizes as possible,
        while also being small enough not to occupy a significant amount of memory for the life
        of the connection pool.
        """
    @buffer_reclaim_threshold.setter
    def buffer_reclaim_threshold(self, value: builtins.int) -> None: ...
    @property
    def tend_interval(self) -> builtins.int:
        r"""
        TendInterval determines interval for checking for cluster state changes.
        Minimum possible interval is 10 Milliseconds.
        """
    @tend_interval.setter
    def tend_interval(self, value: builtins.int) -> None: ...
    @property
    def ip_map(self) -> typing.Any:
        r"""
        A IP translation table is used in cases where different clients
        use different server IP addresses.  This may be necessary when
        using clients from both inside and outside a local area
        network. Default is no translation.
        The key is the IP address returned from friend info requests to other servers.
        The value is the real IP address used to connect to the server.
        """
    @ip_map.setter
    def ip_map(self, value: typing.Optional[dict]) -> None: ...
    @property
    def cluster_name(self) -> typing.Optional[builtins.str]:
        r"""
        Expected cluster name. It not `None`, server nodes must return this cluster name in order
        to join the client's view of the cluster. Should only be set when connecting to servers
        that support the "cluster-name" info command.
        """
    @cluster_name.setter
    def cluster_name(self, value: typing.Optional[builtins.str]) -> None: ...
    def __new__(cls) -> ClientPolicy: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __copy__(self) -> ClientPolicy: ...
    def __deepcopy__(self, _memo:dict) -> ClientPolicy: ...

class Expiration:
    NAMESPACE_DEFAULT: Expiration = ...
    NEVER_EXPIRE: Expiration = ...
    DONT_UPDATE: Expiration = ...
    @staticmethod
    def seconds(s:builtins.int) -> Expiration: ...
    def __richcmp__(self, other:Expiration, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...

class Filter:
    r"""
    Query filter definition. Currently, only one filter is allowed in a Statement, and must be on a
    bin which has a secondary index defined.

    Filter instances should be instantiated using one of the provided macros:

    - `as_eq`
    - `as_range`
    - `as_contains`
    - `as_contains_range`
    - `as_within_region`
    - `as_within_radius`
    - `as_regions_containing_point`
    """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    @staticmethod
    def equal(bin_name:builtins.str, value:typing.Any) -> Filter: ...
    @staticmethod
    def range(bin_name:builtins.str, begin:typing.Any, end:typing.Any) -> Filter: ...
    @staticmethod
    def contains(bin_name:builtins.str, value:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def contains_range(bin_name:builtins.str, begin:typing.Any, end:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_region(bin_name:builtins.str, region:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_radius(bin_name:builtins.str, lng:builtins.float, lat:builtins.float, radius:builtins.float, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def regions_containing_point(bin_name:builtins.str, point:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...

class FilterExpression:
    r"""
    Filter expression, which can be applied to most commands, to control which records are
    affected by the command.
    """
    @staticmethod
    def key(exp_type:ExpType) -> FilterExpression:
        r"""
        Create a record key expression of specified type.
        """
    @staticmethod
    def key_exists() -> FilterExpression:
        r"""
        Create function that returns if the primary key is stored in the record meta data
        as a boolean expression. This would occur when `send_key` is true on record write.
        """
    @staticmethod
    def int_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit int bin expression.
        """
    @staticmethod
    def string_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create string bin expression.
        """
    @staticmethod
    def blob_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create blob bin expression.
        """
    @staticmethod
    def float_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit float bin expression.
        """
    @staticmethod
    def geo_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create geo bin expression.
        """
    @staticmethod
    def list_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create list bin expression.
        """
    @staticmethod
    def map_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create map bin expression.
        """
    @staticmethod
    def hll_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create a HLL bin expression
        """
    @staticmethod
    def bin_exists(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns if bin of specified name exists.
        """
    @staticmethod
    def bin_type(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns bin's integer particle type.
        """
    @staticmethod
    def set_name() -> FilterExpression:
        r"""
        Create function that returns record set name string.
        """
    @staticmethod
    def device_size() -> FilterExpression:
        r"""
        Create function that returns record size on disk.
        If server storage-engine is memory, then zero is returned.
        """
    @staticmethod
    def last_update() -> FilterExpression:
        r"""
        Create function that returns record last update time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def since_update() -> FilterExpression:
        r"""
        Create expression that returns milliseconds since the record was last updated.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def void_time() -> FilterExpression:
        r"""
        Create function that returns record expiration time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def ttl() -> FilterExpression:
        r"""
        Create function that returns record expiration time (time to live) in integer seconds.
        """
    @staticmethod
    def is_tombstone() -> FilterExpression:
        r"""
        Create expression that returns if record has been deleted and is still in tombstone state.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def digest_modulo(modulo:builtins.int) -> FilterExpression:
        r"""
        Create function that returns record digest modulo as integer.
        """
    @staticmethod
    def regex_compare(regex:builtins.str, flags:builtins.int, bin:FilterExpression) -> FilterExpression:
        r"""
        Create function like regular expression string operation.
        """
    @staticmethod
    def geo_compare(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create compare geospatial operation.
        """
    @staticmethod
    def int_val(val:builtins.int) -> FilterExpression:
        r"""
        Creates 64 bit integer value
        """
    @staticmethod
    def bool_val(val:builtins.bool) -> FilterExpression:
        r"""
        Creates a Boolean value
        """
    @staticmethod
    def string_val(val:builtins.str) -> FilterExpression:
        r"""
        Creates String bin value
        """
    @staticmethod
    def float_val(val:builtins.float) -> FilterExpression:
        r"""
        Creates 64 bit float bin value
        """
    @staticmethod
    def blob_val(val:typing.Sequence[builtins.int]) -> FilterExpression:
        r"""
        Creates Blob bin value
        """
    @staticmethod
    def geo_val(val:builtins.str) -> FilterExpression:
        r"""
        Create geospatial json string value.
        """
    @staticmethod
    def nil() -> FilterExpression:
        r"""
        Create a Nil PHPValue
        """
    @staticmethod
    def not_(exp:FilterExpression) -> FilterExpression:
        r"""
        Create "not" operator expression.
        """
    @staticmethod
    def and_(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "and" (&&) operator that applies to a variable number of expressions.
        // (a > 5 || a == 0) && b < 3
        """
    @staticmethod
    def or_(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "or" (||) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "xor" (^) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def eq(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create equal (==) expression.
        """
    @staticmethod
    def ne(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create not equal (!=) expression
        """
    @staticmethod
    def gt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than (>) operation.
        """
    @staticmethod
    def ge(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than or equal (>=) operation.
        """
    @staticmethod
    def lt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than (<) operation.
        """
    @staticmethod
    def le(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than or equals (<=) operation.
        """
    @staticmethod
    def num_add(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "add" (+) operator that applies to a variable number of expressions.
        Return sum of all `FilterExpressions` given. All arguments must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_sub(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "subtract" (-) operator that applies to a variable number of expressions.
        If only one `FilterExpressions` is provided, return the negation of that argument.
        Otherwise, return the sum of the 2nd to Nth `FilterExpressions` subtracted from the 1st
        `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mul(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "multiply" (*) operator that applies to a variable number of expressions.
        Return the product of all `FilterExpressions`. If only one `FilterExpressions` is supplied, return
        that `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_div(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "divide" (/) operator that applies to a variable number of expressions.
        If there is only one `FilterExpressions`, returns the reciprocal for that `FilterExpressions`.
        Otherwise, return the first `FilterExpressions` divided by the product of the rest.
        All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_pow(base:FilterExpression, exponent:FilterExpression) -> FilterExpression:
        r"""
        Create "power" operator that raises a "base" to the "exponent" power.
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_log(num:FilterExpression, base:FilterExpression) -> FilterExpression:
        r"""
        Create "log" operator for logarithm of "num" with base "base".
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mod(numerator:FilterExpression, denominator:FilterExpression) -> FilterExpression:
        r"""
        Create "modulo" (%) operator that determines the remainder of "numerator"
        divided by "denominator". All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_abs(value:FilterExpression) -> FilterExpression:
        r"""
        Create operator that returns absolute value of a number.
        All arguments must resolve to integer or float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_floor(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number down to the closest integer value.
        The return type is float.
        """
    @staticmethod
    def num_ceil(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number up to the closest integer value.
        The return type is float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_int(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts an integer to a float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_float(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts a float to an integer.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_and(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "and" (&) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_or(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "or" (|) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "xor" (^) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_not(exp:FilterExpression) -> FilterExpression:
        r"""
        Create integer "not" (~) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_lshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "left shift" (<<) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "logical right shift" (>>>) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_arshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "arithmetic right shift" (>>) operator.
        The sign bit is preserved and not shifted.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_count(exp:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns count of integer bits that are set to 1.
        Requires server version 5.6.0+
        """
    @staticmethod
    def int_lscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from left (most significant bit) to
        right (least significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from right (least significant bit) to
        left (most significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def min(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the minimum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def max(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the maximum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def cond(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Conditionally select an expression from a variable number of expression pairs
        followed by default expression action.
        Requires server version 5.6.0+.
        ```
        // Args Format: bool exp1, action exp1, bool exp2, action exp2, ..., action-default
        // Apply operator based on type.
        """
    @staticmethod
    def exp_let(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Define variables and expressions in scope.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def def_(name:builtins.str, value:FilterExpression) -> FilterExpression:
        r"""
        Assign variable to an expression that can be accessed later.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def var(name:builtins.str) -> FilterExpression:
        r"""
        Retrieve expression value from a variable.
        Requires server version 5.6.0+.
        """
    def __richcmp__(self, other:FilterExpression, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    @staticmethod
    def unknown() -> FilterExpression:
        r"""
        Create unknown value. Used to intentionally fail an expression.
        The failure can be ignored with `ExpWriteFlags` `EVAL_NO_FAIL`
        or `ExpReadFlags` `EVAL_NO_FAIL`.
        Requires server version 5.6.0+.
        """

class PartitionFilter:
    def __new__(cls) -> PartitionFilter: ...
    def done(self) -> builtins.bool: ...
    @staticmethod
    def all() -> PartitionFilter: ...
    @staticmethod
    def by_id(id:builtins.int) -> PartitionFilter: ...
    @staticmethod
    def by_key(key:Key) -> PartitionFilter: ...
    @staticmethod
    def by_range(begin:builtins.int, count:builtins.int) -> PartitionFilter: ...

class Privilege:
    @property
    def code(self) -> PrivilegeCode: ...
    @property
    def namespace(self) -> typing.Optional[builtins.str]: ...
    @property
    def set_name(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, code:PrivilegeCode, namespace:typing.Optional[builtins.str], set_name:typing.Optional[builtins.str]) -> Privilege: ...
    def as_string(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class QueryPolicy(BasePolicy):
    def __new__(cls) -> QueryPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def records_per_second(self) -> builtins.int: ...
    @records_per_second.setter
    def records_per_second(self, value: builtins.int) -> None: ...
    @property
    def max_records(self) -> builtins.int: ...
    @max_records.setter
    def max_records(self, value: builtins.int) -> None: ...
    @property
    def expected_duration(self) -> QueryDuration: ...
    @expected_duration.setter
    def expected_duration(self, value: QueryDuration) -> None: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...

class ReadPolicy(BasePolicy):
    def __new__(cls) -> ReadPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...

class Recordset:
    r"""
    Virtual collection of records retrieved through queries and scans. During a query/scan,
    multiple threads will retrieve records from the server nodes and put these records on an
    internal queue managed by the recordset. The single user thread consumes these records from the
    queue.
    """
    @property
    def active(self) -> builtins.bool: ...
    def close(self) -> None: ...
    def __aiter__(self) -> Recordset: ...
    def __anext__(self) -> typing.Any: ...

class ScanPolicy(BasePolicy):
    def __new__(cls) -> ScanPolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def socket_timeout(self) -> builtins.int: ...
    @socket_timeout.setter
    def socket_timeout(self, value: builtins.int) -> None: ...

class Statement:
    r"""
    Query statement parameters.
    """
    @property
    def index_name(self) -> typing.Optional[builtins.str]: ...
    @index_name.setter
    def index_name(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def filters(self) -> typing.Optional[builtins.list[Filter]]: ...
    @filters.setter
    def filters(self, value: typing.Optional[builtins.list[Filter]]) -> None: ...
    def __new__(cls, namespace:builtins.str, set_name:builtins.str, bins:typing.Optional[typing.Sequence[builtins.str]]=None, index_name:typing.Optional[builtins.str]=None) -> Statement: ...

class WritePolicy(BasePolicy):
    def __new__(cls) -> WritePolicy: ...
    @property
    def base_policy(self) -> BasePolicy: ...
    @base_policy.setter
    def base_policy(self, value: BasePolicy) -> None: ...
    @property
    def record_exists_action(self) -> RecordExistsAction: ...
    @record_exists_action.setter
    def record_exists_action(self, value: RecordExistsAction) -> None: ...
    @property
    def generation_policy(self) -> GenerationPolicy: ...
    @generation_policy.setter
    def generation_policy(self, value: GenerationPolicy) -> None: ...
    @property
    def commit_level(self) -> CommitLevel: ...
    @commit_level.setter
    def commit_level(self, value: CommitLevel) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...

class CollectionIndexType(Enum):
    r"""
    Secondary index collection type.
    """
    Default = ...
    List = ...
    MapKeys = ...
    MapValues = ...

class CommitLevel(Enum):
    CommitAll = ...
    CommitMaster = ...

class ConsistencyLevel(Enum):
    ConsistencyOne = ...
    ConsistencyAll = ...

class ExpType(Enum):
    r"""
    Expression Data Types for usage in some `FilterExpressions`
    """
    Nil = ...
    Bool = ...
    Int = ...
    String = ...
    List = ...
    Map = ...
    Blob = ...
    Float = ...
    Geo = ...
    HLL = ...

class GenerationPolicy(Enum):
    None_ = ...
    ExpectGenEqual = ...
    ExpectGenGreater = ...

class IndexType(Enum):
    r"""
    Underlying data type of secondary index.
    """
    Numeric = ...
    String = ...
    Geo2DSphere = ...

class PrivilegeCode(Enum):
    r"""
    Secondary index collection type.
    """
    UserAdmin = ...
    r"""
    User can edit/remove other users.  Global scope only.
    """
    SysAdmin = ...
    r"""
    User can perform systems administration functions on a database that do not involve user
    administration.  Examples include server configuration.
    Global scope only.
    """
    DataAdmin = ...
    r"""
    User can perform UDF and SINDEX administration actions. Global scope only.
    """
    UDFAdmin = ...
    r"""
    User can perform user defined function(UDF) administration actions.
    Examples include create/drop UDF. Global scope only.
    Requires server version 6+
    """
    SIndexAdmin = ...
    r"""
    User can perform secondary index administration actions.
    Examples include create/drop index. Global scope only.
    Requires server version 6+
    """
    Read = ...
    r"""
    User can read data only.
    """
    ReadWrite = ...
    r"""
    User can read and write data.
    """
    ReadWriteUDF = ...
    r"""
    User can read and write data through user defined functions.
    """
    Write = ...
    r"""
    User can read and write data through user defined functions.
    """
    Truncate = ...
    r"""
    User can truncate data only.
    Requires server version 6+
    """

class QueryDuration(Enum):
    r"""
    Expected query duration. The server treats the query in different ways depending on the expected duration.
    This enum is ignored for aggregation queries, background queries and server versions < 6.0.
    """
    Long = ...
    r"""
    Long specifies that the query is expected to return more than 100 records per node.
    """
    Short = ...
    r"""
    Short specifies that the query is expected to return less than 100 records per node.
    """
    LongRelaxAP = ...
    r"""
    LongRelaxAP will treat query as a Long query, but relax read consistency for AP namespaces.
    """

class RecordExistsAction(Enum):
    r"""
    `RecordExistsAction` determines how to handle record writes based on record generation.
    """
    Update = ...
    UpdateOnly = ...
    Replace = ...
    ReplaceOnly = ...
    CreateOnly = ...

class Replica(Enum):
    r"""
    Priority of operations on database server.
    """
    Master = ...
    Sequence = ...
    PreferRack = ...

def geojson(geo_str:builtins.str) -> GeoJSON:
    r"""
    Convert a GeoJSON string or coordinate pair to a GeoJSON object.
    This matches the legacy client's aerospike.geojson() function.

    Accepts:
    - GeoJSON JSON string: '{"type": "Point", "coordinates": [-122.0, 37.0]}'
    - Coordinate pair string: "-122.0, 37.5" (longitude, latitude)
    """

class Client:
    r"""
    Aerospike async client for database operations.
    Create instances using new_client() function.
    """
    def seeds(self) -> builtins.str: ...
    def close(self) -> typing.Awaitable[typing.Any]: ...
    def is_connected(self) -> typing.Awaitable[builtins.bool]: ...
    def put(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def get(self, policy: ReadPolicy, key: Key, bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Any]: ...
    def add(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def append(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def prepend(self, policy: WritePolicy, key: Key, bins: typing.Dict[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]: ...
    def delete(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def touch(self, policy: WritePolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Any]: ...
    def exists_legacy(self, policy: ReadPolicy, key: Key) -> typing.Awaitable[typing.Tuple[Key, typing.Optional[typing.Any]]]: ...
    def truncate(self, namespace: builtins.str, set_name: builtins.str, before_nanos: typing.Optional[builtins.int] = None) -> typing.Awaitable[typing.Any]: ...
    def create_index(self, namespace: builtins.str, set_name: builtins.str, bin_name: builtins.str, index_name: builtins.str, index_type: IndexType, cit: typing.Optional[CollectionIndexType] = None) -> typing.Awaitable[typing.Any]: ...
    def drop_index(self, namespace: builtins.str, set_name: builtins.str, index_name: builtins.str) -> typing.Awaitable[typing.Any]: ...
    def scan(self, policy: ScanPolicy, partition_filter: PartitionFilter, namespace: builtins.str, set_name: builtins.str, bins: typing.Optional[typing.Sequence[builtins.str]] = None) -> typing.Awaitable[typing.Any]: ...
    def query(self, policy: QueryPolicy, partition_filter: PartitionFilter, statement: Statement) -> typing.Awaitable[typing.Any]: ...
    def create_user(self, user: builtins.str, password: builtins.str, roles: typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]: ...
    def drop_user(self, user: builtins.str) -> typing.Awaitable[typing.Any]: ...

def new_client(policy:ClientPolicy, seeds:builtins.str) -> typing.Awaitable[Client]: ...

def null() -> typing.Any:
    r"""
    Return a null value for use in Aerospike operations.
    This is equivalent to Python None but represents an Aerospike null value.
    Matches the legacy client's aerospike.null() function.
    """

