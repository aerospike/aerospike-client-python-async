# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from ._aerospike_async_native import Key
from . import _aerospike_async_native
from enum import Enum

class BasePolicy:
    @property
    def consistency_level(self) -> ConsistencyLevel: ...
    @consistency_level.setter
    def consistency_level(self, value: ConsistencyLevel) -> None: ...
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    @property
    def max_retries(self) -> typing.Optional[builtins.int]: ...
    @max_retries.setter
    def max_retries(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def sleep_between_retries(self) -> builtins.int: ...
    @sleep_between_retries.setter
    def sleep_between_retries(self, value: builtins.int) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    def __new__(cls) -> BasePolicy: ...

class ClientPolicy:
    @property
    def user(self) -> typing.Optional[builtins.str]: ...
    @user.setter
    def user(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def password(self) -> typing.Optional[builtins.str]: ...
    @password.setter
    def password(self, value: typing.Optional[builtins.str]) -> None: ...
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    @property
    def idle_timeout(self) -> builtins.int:
        r"""
        Connection idle timeout. Every time a connection is used, its idle
        deadline will be extended by this duration. When this deadline is reached,
        the connection will be closed and discarded from the connection pool.
        """
    @idle_timeout.setter
    def idle_timeout(self, value: builtins.int) -> None: ...
    @property
    def max_conns_per_node(self) -> builtins.int: ...
    @max_conns_per_node.setter
    def max_conns_per_node(self, value: builtins.int) -> None: ...
    @property
    def conn_pools_per_node(self) -> builtins.int:
        r"""
        Number of connection pools used for each node. Machines with 8 CPU cores or less usually
        need only one connection pool per node. Machines with larger number of CPU cores may have
        their performance limited by contention for pooled connections. Contention for pooled
        connections can be reduced by creating multiple mini connection pools per node.
        """
    @conn_pools_per_node.setter
    def conn_pools_per_node(self, value: builtins.int) -> None: ...
    def __new__(cls) -> ClientPolicy: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __copy__(self) -> ClientPolicy: ...
    def __deepcopy__(self, _memo:dict) -> ClientPolicy: ...

class Expiration:
    NAMESPACE_DEFAULT: Expiration = ...
    NEVER_EXPIRE: Expiration = ...
    DONT_UPDATE: Expiration = ...
    @staticmethod
    def seconds(s:builtins.int) -> Expiration: ...
    def __richcmp__(self, other:Expiration, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...

class Filter:
    r"""
    Query filter definition. Currently, only one filter is allowed in a Statement, and must be on a
    bin which has a secondary index defined.
    
    Filter instances should be instantiated using one of the provided macros:
    
    - `as_eq`
    - `as_range`
    - `as_contains`
    - `as_contains_range`
    - `as_within_region`
    - `as_within_radius`
    - `as_regions_containing_point`
    """
    @staticmethod
    def range(bin_name:builtins.str, begin:typing.Any, end:typing.Any) -> Filter: ...
    @staticmethod
    def contains(bin_name:builtins.str, value:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def contains_range(bin_name:builtins.str, begin:typing.Any, end:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_region(bin_name:builtins.str, region:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_radius(bin_name:builtins.str, lat:builtins.float, lng:builtins.float, radius:builtins.float, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def regions_containing_point(bin_name:builtins.str, point:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...

class FilterExpression:
    r"""
    Filter expression, which can be applied to most commands, to control which records are
    affected by the command.
    """
    @staticmethod
    def key(exp_type:ExpType) -> FilterExpression:
        r"""
        Create a record key expression of specified type.
        """
    @staticmethod
    def key_exists() -> FilterExpression:
        r"""
        Create function that returns if the primary key is stored in the record meta data
        as a boolean expression. This would occur when `send_key` is true on record write.
        """
    @staticmethod
    def int_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit int bin expression.
        """
    @staticmethod
    def string_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create string bin expression.
        """
    @staticmethod
    def blob_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create blob bin expression.
        """
    @staticmethod
    def float_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit float bin expression.
        """
    @staticmethod
    def geo_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create geo bin expression.
        """
    @staticmethod
    def list_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create list bin expression.
        """
    @staticmethod
    def map_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create map bin expression.
        """
    @staticmethod
    def hll_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create a HLL bin expression
        """
    @staticmethod
    def bin_exists(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns if bin of specified name exists.
        """
    @staticmethod
    def bin_type(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns bin's integer particle type.
        """
    @staticmethod
    def set_name() -> FilterExpression:
        r"""
        Create function that returns record set name string.
        """
    @staticmethod
    def device_size() -> FilterExpression:
        r"""
        Create function that returns record size on disk.
        If server storage-engine is memory, then zero is returned.
        """
    @staticmethod
    def last_update() -> FilterExpression:
        r"""
        Create function that returns record last update time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def since_update() -> FilterExpression:
        r"""
        Create expression that returns milliseconds since the record was last updated.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def void_time() -> FilterExpression:
        r"""
        Create function that returns record expiration time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def ttl() -> FilterExpression:
        r"""
        Create function that returns record expiration time (time to live) in integer seconds.
        """
    @staticmethod
    def is_tombstone() -> FilterExpression:
        r"""
        Create expression that returns if record has been deleted and is still in tombstone state.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def digest_modulo(modulo:builtins.int) -> FilterExpression:
        r"""
        Create function that returns record digest modulo as integer.
        """
    @staticmethod
    def regex_compare(regex:builtins.str, flags:builtins.int, bin:FilterExpression) -> FilterExpression:
        r"""
        Create function like regular expression string operation.
        """
    @staticmethod
    def geo_compare(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create compare geospatial operation.
        """
    @staticmethod
    def int_val(val:builtins.int) -> FilterExpression:
        r"""
        Creates 64 bit integer value
        """
    @staticmethod
    def bool_val(val:builtins.bool) -> FilterExpression:
        r"""
        Creates a Boolean value
        """
    @staticmethod
    def string_val(val:builtins.str) -> FilterExpression:
        r"""
        Creates String bin value
        """
    @staticmethod
    def float_val(val:builtins.float) -> FilterExpression:
        r"""
        Creates 64 bit float bin value
        """
    @staticmethod
    def blob_val(val:typing.Sequence[builtins.int]) -> FilterExpression:
        r"""
        Creates Blob bin value
        """
    @staticmethod
    def geo_val(val:builtins.str) -> FilterExpression:
        r"""
        Create geospatial json string value.
        """
    @staticmethod
    def nil() -> FilterExpression:
        r"""
        Create a Nil PHPValue
        """
    @staticmethod
    def not_(exp:FilterExpression) -> FilterExpression:
        r"""
        Create "not" operator expression.
        """
    @staticmethod
    def and_(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "and" (&&) operator that applies to a variable number of expressions.
        // (a > 5 || a == 0) && b < 3
        """
    @staticmethod
    def or_(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "or" (||) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "xor" (^) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def eq(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create equal (==) expression.
        """
    @staticmethod
    def ne(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create not equal (!=) expression
        """
    @staticmethod
    def gt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than (>) operation.
        """
    @staticmethod
    def ge(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than or equal (>=) operation.
        """
    @staticmethod
    def lt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than (<) operation.
        """
    @staticmethod
    def le(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than or equals (<=) operation.
        """
    @staticmethod
    def num_add(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "add" (+) operator that applies to a variable number of expressions.
        Return sum of all `FilterExpressions` given. All arguments must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_sub(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "subtract" (-) operator that applies to a variable number of expressions.
        If only one `FilterExpressions` is provided, return the negation of that argument.
        Otherwise, return the sum of the 2nd to Nth `FilterExpressions` subtracted from the 1st
        `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mul(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "multiply" (*) operator that applies to a variable number of expressions.
        Return the product of all `FilterExpressions`. If only one `FilterExpressions` is supplied, return
        that `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_div(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "divide" (/) operator that applies to a variable number of expressions.
        If there is only one `FilterExpressions`, returns the reciprocal for that `FilterExpressions`.
        Otherwise, return the first `FilterExpressions` divided by the product of the rest.
        All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_pow(base:FilterExpression, exponent:FilterExpression) -> FilterExpression:
        r"""
        Create "power" operator that raises a "base" to the "exponent" power.
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_log(num:FilterExpression, base:FilterExpression) -> FilterExpression:
        r"""
        Create "log" operator for logarithm of "num" with base "base".
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mod(numerator:FilterExpression, denominator:FilterExpression) -> FilterExpression:
        r"""
        Create "modulo" (%) operator that determines the remainder of "numerator"
        divided by "denominator". All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_abs(value:FilterExpression) -> FilterExpression:
        r"""
        Create operator that returns absolute value of a number.
        All arguments must resolve to integer or float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_floor(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number down to the closest integer value.
        The return type is float.
        """
    @staticmethod
    def num_ceil(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number up to the closest integer value.
        The return type is float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_int(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts an integer to a float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_float(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts a float to an integer.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_and(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "and" (&) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_or(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "or" (|) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "xor" (^) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_not(exp:FilterExpression) -> FilterExpression:
        r"""
        Create integer "not" (~) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_lshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "left shift" (<<) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "logical right shift" (>>>) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_arshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "arithmetic right shift" (>>) operator.
        The sign bit is preserved and not shifted.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_count(exp:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns count of integer bits that are set to 1.
        Requires server version 5.6.0+
        """
    @staticmethod
    def int_lscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from left (most significant bit) to
        right (least significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from right (least significant bit) to
        left (most significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def min(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the minimum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def max(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the maximum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def cond(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Conditionally select an expression from a variable number of expression pairs
        followed by default expression action.
        Requires server version 5.6.0+.
        ```
        // Args Format: bool exp1, action exp1, bool exp2, action exp2, ..., action-default
        // Apply operator based on type.
        """
    @staticmethod
    def exp_let(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Define variables and expressions in scope.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def def_(name:builtins.str, value:FilterExpression) -> FilterExpression:
        r"""
        Assign variable to an expression that can be accessed later.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def var(name:builtins.str) -> FilterExpression:
        r"""
        Retrieve expression value from a variable.
        Requires server version 5.6.0+.
        """
    def __richcmp__(self, other:FilterExpression, op:int) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    @staticmethod
    def unknown() -> FilterExpression:
        r"""
        Create unknown value. Used to intentionally fail an expression.
        The failure can be ignored with `ExpWriteFlags` `EVAL_NO_FAIL`
        or `ExpReadFlags` `EVAL_NO_FAIL`.
        Requires server version 5.6.0+.
        """

class PartitionFilter:
    def __new__(cls) -> PartitionFilter: ...
    def done(self) -> builtins.bool: ...
    @staticmethod
    def all() -> PartitionFilter: ...
    @staticmethod
    def by_id(id:builtins.int) -> PartitionFilter: ...
    @staticmethod
    def by_key(key:Key) -> PartitionFilter: ...
    @staticmethod
    def by_range(begin:builtins.int, count:builtins.int) -> PartitionFilter: ...

class Privilege:
    @property
    def code(self) -> PrivilegeCode: ...
    @property
    def namespace(self) -> typing.Optional[builtins.str]: ...
    @property
    def set_name(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, code:PrivilegeCode, namespace:typing.Optional[builtins.str], set_name:typing.Optional[builtins.str]) -> Privilege: ...
    def as_string(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class QueryPolicy:
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def fail_on_cluster_change(self) -> builtins.bool: ...
    @fail_on_cluster_change.setter
    def fail_on_cluster_change(self, value: builtins.bool) -> None: ...
    def __new__(cls) -> QueryPolicy: ...

class ReadPolicy(BasePolicy):
    def __new__(cls) -> ReadPolicy: ...
    @property
    def replica(self) -> Replica: ...
    @replica.setter
    def replica(self, value: Replica) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...

class Recordset:
    r"""
    Virtual collection of records retrieved through queries and scans. During a query/scan,
    multiple threads will retrieve records from the server nodes and put these records on an
    internal queue managed by the recordset. The single user thread consumes these records from the
    queue.
    """
    @property
    def active(self) -> builtins.bool: ...
    def close(self) -> None: ...
    def __iter__(self) -> Recordset: ...
    def __next__(self) -> typing.Optional[typing.Any]: ...

class ScanPolicy:
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def socket_timeout(self) -> builtins.int: ...
    @socket_timeout.setter
    def socket_timeout(self, value: builtins.int) -> None: ...
    def __new__(cls) -> ScanPolicy: ...

class Statement:
    r"""
    Query statement parameters.
    """
    @property
    def filters(self) -> typing.Optional[builtins.list[Filter]]: ...
    @filters.setter
    def filters(self, value: typing.Optional[builtins.list[Filter]]) -> None: ...
    def __new__(cls, namespace:builtins.str, set_name:builtins.str, bins:typing.Optional[typing.Sequence[builtins.str]]) -> Statement: ...

class WritePolicy(BasePolicy):
    def __new__(cls) -> WritePolicy: ...
    @property
    def record_exists_action(self) -> RecordExistsAction: ...
    @record_exists_action.setter
    def record_exists_action(self, value: RecordExistsAction) -> None: ...
    @property
    def generation_policy(self) -> GenerationPolicy: ...
    @generation_policy.setter
    def generation_policy(self, value: GenerationPolicy) -> None: ...
    @property
    def commit_level(self) -> CommitLevel: ...
    @commit_level.setter
    def commit_level(self, value: CommitLevel) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...

class CollectionIndexType(Enum):
    r"""
    Secondary index collection type.
    """
    Default = ...
    List = ...
    MapKeys = ...
    MapValues = ...

class CommitLevel(Enum):
    CommitAll = ...
    CommitMaster = ...

class ConsistencyLevel(Enum):
    ConsistencyOne = ...
    ConsistencyAll = ...

class ExpType(Enum):
    r"""
    Expression Data Types for usage in some `FilterExpressions`
    """
    Nil = ...
    Bool = ...
    Int = ...
    String = ...
    List = ...
    Map = ...
    Blob = ...
    Float = ...
    Geo = ...
    HLL = ...

class GenerationPolicy(Enum):
    None_ = ...
    ExpectGenEqual = ...
    ExpectGenGreater = ...

class IndexType(Enum):
    r"""
    Underlying data type of secondary index.
    """
    Numeric = ...
    String = ...
    Geo2DSphere = ...

class PrivilegeCode(Enum):
    r"""
    Secondary index collection type.
    """
    UserAdmin = ...
    r"""
    User can edit/remove other users.  Global scope only.
    """
    SysAdmin = ...
    r"""
    User can perform systems administration functions on a database that do not involve user
    administration.  Examples include server configuration.
    Global scope only.
    """
    DataAdmin = ...
    r"""
    User can perform UDF and SINDEX administration actions. Global scope only.
    """
    UDFAdmin = ...
    r"""
    User can perform user defined function(UDF) administration actions.
    Examples include create/drop UDF. Global scope only.
    Requires server version 6+
    """
    SIndexAdmin = ...
    r"""
    User can perform secondary index administration actions.
    Examples include create/drop index. Global scope only.
    Requires server version 6+
    """
    Read = ...
    r"""
    User can read data only.
    """
    ReadWrite = ...
    r"""
    User can read and write data.
    """
    ReadWriteUDF = ...
    r"""
    User can read and write data through user defined functions.
    """
    Write = ...
    r"""
    User can read and write data through user defined functions.
    """
    Truncate = ...
    r"""
    User can truncate data only.
    Requires server version 6+
    """

class RecordExistsAction(Enum):
    r"""
    `RecordExistsAction` determines how to handle record writes based on record generation.
    """
    Update = ...
    UpdateOnly = ...
    Replace = ...
    ReplaceOnly = ...
    CreateOnly = ...

class Replica(Enum):
    r"""
    Priority of operations on database server.
    """
    Master = ...
    Sequence = ...
    PreferRack = ...

def new_client(policy:ClientPolicy, seeds:builtins.str) -> typing.Awaitable[Client]: ...


# Exception classes (added by post-processing script)
class AerospikeError(builtins.Exception):
    """Base exception class for all Aerospike-specific errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ServerError(AerospikeError):
    """Exception raised when the Aerospike server returns an error."""
    def __init__(self, message: builtins.str) -> None: ...

class UDFBadResponse(AerospikeError):
    """Exception raised when a UDF (User Defined Function) returns a bad response."""
    def __init__(self, message: builtins.str) -> None: ...

class TimeoutError(AerospikeError):
    """Exception raised when an operation times out."""
    def __init__(self, message: builtins.str) -> None: ...

class Base64DecodeError(AerospikeError):
    """Exception raised when Base64 decoding fails."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidUTF8(AerospikeError):
    """Exception raised when invalid UTF-8 is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class IoError(AerospikeError):
    """Exception raised for I/O related errors."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseAddressError(AerospikeError):
    """Exception raised when parsing an address fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ParseIntError(AerospikeError):
    """Exception raised when parsing an integer fails."""
    def __init__(self, message: builtins.str) -> None: ...

class ConnectionError(AerospikeError):
    """Exception raised when a connection error occurs."""
    def __init__(self, message: builtins.str) -> None: ...

class ValueError(AerospikeError):
    """Exception raised when an invalid value is provided."""
    def __init__(self, message: builtins.str) -> None: ...

class RecvError(AerospikeError):
    """Exception raised when receiving data fails."""
    def __init__(self, message: builtins.str) -> None: ...

class PasswordHashError(AerospikeError):
    """Exception raised when password hashing fails."""
    def __init__(self, message: builtins.str) -> None: ...

class BadResponse(AerospikeError):
    """Exception raised when a bad response is received."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidRustClientArgs(AerospikeError):
    """Exception raised when invalid arguments are provided to the Rust client."""
    def __init__(self, message: builtins.str) -> None: ...

class InvalidNodeError(AerospikeError):
    """Exception raised when an invalid node is encountered."""
    def __init__(self, message: builtins.str) -> None: ...

class NoMoreConnections(AerospikeError):
    """Exception raised when no more connections are available."""
    def __init__(self, message: builtins.str) -> None: ...
