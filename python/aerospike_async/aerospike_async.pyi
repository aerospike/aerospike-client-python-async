# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

class BasePolicy:
    @property
    def consistency_level(self) -> typing.Any: ...
    @consistency_level.setter
    def consistency_level(self, value: typing.Any) -> None: ...
    @property
    def timeout(self) -> builtins.int: ...
    @timeout.setter
    def timeout(self, value: builtins.int) -> None: ...
    @property
    def max_retries(self) -> typing.Optional[builtins.int]: ...
    @max_retries.setter
    def max_retries(self, value: typing.Optional[builtins.int]) -> None: ...
    @property
    def sleep_between_retries(self) -> builtins.int: ...
    @sleep_between_retries.setter
    def sleep_between_retries(self, value: builtins.int) -> None: ...
    @property
    def filter_expression(self) -> typing.Optional[FilterExpression]: ...
    @filter_expression.setter
    def filter_expression(self, value: typing.Optional[FilterExpression]) -> None: ...
    def __new__(cls) -> BasePolicy: ...

class Blob:
    @property
    def value(self) -> builtins.list[builtins.int]: ...
    @value.setter
    def value(self, value: builtins.list[builtins.int]) -> None: ...
    def __new__(cls, v:typing.Sequence[builtins.int]) -> Blob: ...
    def as_string(self) -> builtins.str:
        r"""
        Returns a string representation of the value.
        """
    def __getitem__(self, idx:builtins.int) -> builtins.int: ...
    def __setitem__(self, idx:builtins.int, v:builtins.int) -> None: ...
    def __hash__(self) -> builtins.int: ...
    def __richcmp__(self, other:typing.Any, op:int) -> builtins.bool: ...

class Client:
    def __new__(cls) -> Client: ...
    def seeds(self) -> builtins.str: ...
    def close(self) -> None: ...
    def put(self, policy:WritePolicy, key:Key, bins:typing.Mapping[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]:
        r"""
        Write record bin(s). The policy specifies the transaction timeout, record expiration and
        how the transaction is handled when the record already exists.
        """
    def get(self, policy:ReadPolicy, key:Key, bins:typing.Optional[typing.Sequence[builtins.str]]=None) -> typing.Awaitable[typing.Any]:
        r"""
        Read record for the specified key. Depending on the bins value provided, all record bins,
        only selected record bins or only the record headers will be returned. The policy can be
        used to specify timeouts.
        """
    def add(self, policy:WritePolicy, key:Key, bins:typing.Mapping[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]:
        r"""
        Add integer bin values to existing record bin values. The policy specifies the transaction
        timeout, record expiration and how the transaction is handled when the record already
        exists. This call only works for integer values.
        """
    def append(self, policy:WritePolicy, key:Key, bins:typing.Mapping[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]:
        r"""
        Append bin string values to existing record bin values. The policy specifies the
        transaction timeout, record expiration and how the transaction is handled when the record
        already exists. This call only works for string values.
        """
    def prepend(self, policy:WritePolicy, key:Key, bins:typing.Mapping[builtins.str, typing.Any]) -> typing.Awaitable[typing.Any]:
        r"""
        Prepend bin string values to existing record bin values. The policy specifies the
        transaction timeout, record expiration and how the transaction is handled when the record
        already exists. This call only works for string values.
        """
    def delete(self, policy:WritePolicy, key:Key) -> typing.Awaitable[typing.Any]:
        r"""
        Delete record for specified key. The policy specifies the transaction timeout.
        The call returns `true` if the record existed on the server before deletion.
        """
    def touch(self, policy:WritePolicy, key:Key) -> typing.Awaitable[typing.Any]:
        r"""
        Reset record's time to expiration using the policy's expiration. Fail if the record does
        not exist.
        """
    def exists(self, policy:ReadPolicy, key:Key) -> typing.Awaitable[typing.Any]:
        r"""
        Determine if a record key exists. The policy can be used to specify timeouts.
        """
    def truncate(self, namespace:builtins.str, set_name:builtins.str, before_nanos:typing.Optional[builtins.int]) -> typing.Awaitable[typing.Any]:
        r"""
        Removes all records in the specified namespace/set efficiently.
        """
    def create_index(self, namespace:builtins.str, set_name:builtins.str, bin_name:builtins.str, index_name:builtins.str, index_type:IndexType, cit:typing.Optional[CollectionIndexType]) -> typing.Awaitable[typing.Any]:
        r"""
        Create a secondary index on a bin containing scalar values. This asynchronous server call
        returns before the command is complete.
        """
    def drop_index(self, namespace:builtins.str, set_name:builtins.str, index_name:builtins.str) -> typing.Awaitable[typing.Any]: ...
    def scan(self, policy:ScanPolicy, partition_filter:PartitionFilter, namespace:builtins.str, set_name:builtins.str, bins:typing.Optional[typing.Sequence[builtins.str]]) -> typing.Awaitable[typing.Any]:
        r"""
        Read all records in the specified namespace and set and return a record iterator. The scan
        executor puts records on a queue in separate threads. The calling thread concurrently pops
        records off the queue through the record iterator. Up to `policy.max_concurrent_nodes`
        nodes are scanned in parallel. If concurrent nodes is set to zero, the server nodes are
        read in series.
        """
    def query(self, policy:QueryPolicy, partition_filter:PartitionFilter, statement:Statement) -> typing.Awaitable[typing.Any]:
        r"""
        Execute a query on all server nodes and return a record iterator. The query executor puts
        records on a queue in separate threads. The calling thread concurrently pops records off
        the queue through the record iterator.
        """
    def create_user(self, user:builtins.str, password:builtins.str, roles:typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]:
        r"""
        Creates a new user with password and roles. Clear-text password will be hashed using bcrypt
        before sending to server.
        """
    def drop_user(self, user:builtins.str) -> typing.Awaitable[typing.Any]:
        r"""
        Removes a user from the cluster.
        """
    def change_password(self, user:builtins.str, password:builtins.str) -> typing.Awaitable[typing.Any]:
        r"""
        Changes a user's password. Clear-text password will be hashed using bcrypt before sending to server.
        """
    def grant_roles(self, user:builtins.str, roles:typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]:
        r"""
        Adds roles to user's list of roles.
        """
    def revoke_roles(self, user:builtins.str, roles:typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]:
        r"""
        Removes roles from user's list of roles.
        """
    def query_users(self, user:typing.Optional[builtins.str]) -> typing.Awaitable[typing.Any]:
        r"""
        Retrieves users and their roles.
        If None is passed for the user argument, all users will be returned.
        """
    def query_roles(self, role:typing.Optional[builtins.str]) -> typing.Awaitable[typing.Any]:
        r"""
        Retrieves roles and their privileges.
        If None is passed for the role argument, all roles will be returned.
        """
    def create_role(self, role_name:builtins.str, privileges:typing.Sequence[Privilege], allowlist:typing.Sequence[builtins.str], read_quota:builtins.int, write_quota:builtins.int) -> typing.Awaitable[typing.Any]:
        r"""
        Creates a user-defined role.
        Quotas require server security configuration "enable-quotas" to be set to true.
        Pass 0 for quota values for no limit.
        """
    def drop_role(self, role_name:builtins.str) -> typing.Awaitable[typing.Any]:
        r"""
        Removes a user-defined role.
        """
    def grant_privileges(self, role_name:builtins.str, privileges:typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]:
        r"""
        Grants privileges to a user-defined role.
        """
    def revoke_privileges(self, role_name:builtins.str, privileges:typing.Sequence[Privilege]) -> typing.Awaitable[typing.Any]:
        r"""
        Revokes privileges from a user-defined role.
        """
    def set_allowlist(self, role_name:builtins.str, allowlist:typing.Sequence[builtins.str]) -> typing.Awaitable[typing.Any]:
        r"""
        Sets IP address allowlist for a role.
        If allowlist is nil or empty, it removes existing allowlist from role.
        """
    def set_quotas(self, role_name:builtins.str, read_quota:builtins.int, write_quota:builtins.int) -> typing.Awaitable[typing.Any]:
        r"""
        Sets maximum reads/writes per second limits for a role.
        If a quota is zero, the limit is removed.
        Quotas require server security configuration "enable-quotas" to be set to true.
        Pass 0 for quota values for no limit.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __copy__(self) -> Client: ...
    def __deepcopy__(self, _memo:dict) -> Client: ...

class ClientPolicy:
    ...

class Expiration:
    ...

class Filter:
    r"""
    Query filter definition. Currently, only one filter is allowed in a Statement, and must be on a
    bin which has a secondary index defined.
    
    Filter instances should be instantiated using one of the provided macros:
    
    - `as_eq`
    - `as_range`
    - `as_contains`
    - `as_contains_range`
    - `as_within_region`
    - `as_within_radius`
    - `as_regions_containing_point`
    """
    @staticmethod
    def range(bin_name:builtins.str, begin:typing.Any, end:typing.Any) -> Filter: ...
    @staticmethod
    def contains(bin_name:builtins.str, value:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def contains_range(bin_name:builtins.str, begin:typing.Any, end:typing.Any, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_region(bin_name:builtins.str, region:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def within_radius(bin_name:builtins.str, lat:builtins.float, lng:builtins.float, radius:builtins.float, cit:typing.Optional[CollectionIndexType]) -> Filter: ...
    @staticmethod
    def regions_containing_point(bin_name:builtins.str, point:builtins.str, cit:typing.Optional[CollectionIndexType]) -> Filter: ...

class FilterExpression:
    r"""
    Filter expression, which can be applied to most commands, to control which records are
    affected by the command.
    """
    @staticmethod
    def key(exp_type:typing.Any) -> FilterExpression:
        r"""
        Create a record key expression of specified type.
        """
    @staticmethod
    def key_exists() -> FilterExpression:
        r"""
        Create function that returns if the primary key is stored in the record meta data
        as a boolean expression. This would occur when `send_key` is true on record write.
        """
    @staticmethod
    def int_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit int bin expression.
        """
    @staticmethod
    def string_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create string bin expression.
        """
    @staticmethod
    def blob_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create blob bin expression.
        """
    @staticmethod
    def float_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create 64 bit float bin expression.
        """
    @staticmethod
    def geo_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create geo bin expression.
        """
    @staticmethod
    def list_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create list bin expression.
        """
    @staticmethod
    def map_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create map bin expression.
        """
    @staticmethod
    def hll_bin(name:builtins.str) -> FilterExpression:
        r"""
        Create a HLL bin expression
        """
    @staticmethod
    def bin_exists(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns if bin of specified name exists.
        """
    @staticmethod
    def bin_type(name:builtins.str) -> FilterExpression:
        r"""
        Create function that returns bin's integer particle type.
        """
    @staticmethod
    def set_name() -> FilterExpression:
        r"""
        Create function that returns record set name string.
        """
    @staticmethod
    def device_size() -> FilterExpression:
        r"""
        Create function that returns record size on disk.
        If server storage-engine is memory, then zero is returned.
        """
    @staticmethod
    def last_update() -> FilterExpression:
        r"""
        Create function that returns record last update time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def since_update() -> FilterExpression:
        r"""
        Create expression that returns milliseconds since the record was last updated.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def void_time() -> FilterExpression:
        r"""
        Create function that returns record expiration time expressed as 64 bit integer
        nanoseconds since 1970-01-01 epoch.
        """
    @staticmethod
    def ttl() -> FilterExpression:
        r"""
        Create function that returns record expiration time (time to live) in integer seconds.
        """
    @staticmethod
    def is_tombstone() -> FilterExpression:
        r"""
        Create expression that returns if record has been deleted and is still in tombstone state.
        This expression usually evaluates quickly because record meta data is cached in memory.
        """
    @staticmethod
    def digest_modulo(modulo:builtins.int) -> FilterExpression:
        r"""
        Create function that returns record digest modulo as integer.
        """
    @staticmethod
    def regex_compare(regex:builtins.str, flags:builtins.int, bin:FilterExpression) -> FilterExpression:
        r"""
        Create function like regular expression string operation.
        """
    @staticmethod
    def geo_compare(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create compare geospatial operation.
        """
    @staticmethod
    def int_val(val:builtins.int) -> FilterExpression:
        r"""
        Creates 64 bit integer value
        """
    @staticmethod
    def bool_val(val:builtins.bool) -> FilterExpression:
        r"""
        Creates a Boolean value
        """
    @staticmethod
    def string_val(val:builtins.str) -> FilterExpression:
        r"""
        Creates String bin value
        """
    @staticmethod
    def float_val(val:builtins.float) -> FilterExpression:
        r"""
        Creates 64 bit float bin value
        """
    @staticmethod
    def blob_val(val:typing.Sequence[builtins.int]) -> FilterExpression:
        r"""
        Creates Blob bin value
        """
    @staticmethod
    def geo_val(val:builtins.str) -> FilterExpression:
        r"""
        Create geospatial json string value.
        """
    @staticmethod
    def nil() -> FilterExpression:
        r"""
        Create a Nil PHPValue
        """
    @staticmethod
    def not(exp:FilterExpression) -> FilterExpression:
        r"""
        Create "not" operator expression.
        """
    @staticmethod
    def and(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "and" (&&) operator that applies to a variable number of expressions.
        // (a > 5 || a == 0) && b < 3
        """
    @staticmethod
    def or(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "or" (||) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "xor" (^) operator that applies to a variable number of expressions.
        """
    @staticmethod
    def eq(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create equal (==) expression.
        """
    @staticmethod
    def ne(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create not equal (!=) expression
        """
    @staticmethod
    def gt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than (>) operation.
        """
    @staticmethod
    def ge(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create greater than or equal (>=) operation.
        """
    @staticmethod
    def lt(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than (<) operation.
        """
    @staticmethod
    def le(left:FilterExpression, right:FilterExpression) -> FilterExpression:
        r"""
        Create less than or equals (<=) operation.
        """
    @staticmethod
    def num_add(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "add" (+) operator that applies to a variable number of expressions.
        Return sum of all `FilterExpressions` given. All arguments must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_sub(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "subtract" (-) operator that applies to a variable number of expressions.
        If only one `FilterExpressions` is provided, return the negation of that argument.
        Otherwise, return the sum of the 2nd to Nth `FilterExpressions` subtracted from the 1st
        `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mul(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "multiply" (*) operator that applies to a variable number of expressions.
        Return the product of all `FilterExpressions`. If only one `FilterExpressions` is supplied, return
        that `FilterExpressions`. All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_div(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create "divide" (/) operator that applies to a variable number of expressions.
        If there is only one `FilterExpressions`, returns the reciprocal for that `FilterExpressions`.
        Otherwise, return the first `FilterExpressions` divided by the product of the rest.
        All `FilterExpressions` must resolve to the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_pow(base:FilterExpression, exponent:FilterExpression) -> FilterExpression:
        r"""
        Create "power" operator that raises a "base" to the "exponent" power.
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_log(num:FilterExpression, base:FilterExpression) -> FilterExpression:
        r"""
        Create "log" operator for logarithm of "num" with base "base".
        All arguments must resolve to floats.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_mod(numerator:FilterExpression, denominator:FilterExpression) -> FilterExpression:
        r"""
        Create "modulo" (%) operator that determines the remainder of "numerator"
        divided by "denominator". All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_abs(value:FilterExpression) -> FilterExpression:
        r"""
        Create operator that returns absolute value of a number.
        All arguments must resolve to integer or float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def num_floor(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number down to the closest integer value.
        The return type is float.
        """
    @staticmethod
    def num_ceil(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that rounds a floating point number up to the closest integer value.
        The return type is float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_int(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts an integer to a float.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def to_float(num:FilterExpression) -> FilterExpression:
        r"""
        Create expression that converts a float to an integer.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_and(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "and" (&) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_or(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "or" (|) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_xor(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create integer "xor" (^) operator that is applied to two or more integers.
        All arguments must resolve to integers.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_not(exp:FilterExpression) -> FilterExpression:
        r"""
        Create integer "not" (~) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_lshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "left shift" (<<) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "logical right shift" (>>>) operator.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_arshift(value:FilterExpression, shift:FilterExpression) -> FilterExpression:
        r"""
        Create integer "arithmetic right shift" (>>) operator.
        The sign bit is preserved and not shifted.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_count(exp:FilterExpression) -> FilterExpression:
        r"""
        Create expression that returns count of integer bits that are set to 1.
        Requires server version 5.6.0+
        """
    @staticmethod
    def int_lscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from left (most significant bit) to
        right (least significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def int_rscan(value:FilterExpression, search:FilterExpression) -> FilterExpression:
        r"""
        Create expression that scans integer bits from right (least significant bit) to
        left (most significant bit), looking for a search bit value. When the
        search value is found, the index of that bit (where the most significant bit is
        index 0) is returned. If "search" is true, the scan will search for the bit
        value 1. If "search" is false it will search for bit value 0.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def min(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the minimum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def max(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Create expression that returns the maximum value in a variable number of expressions.
        All arguments must be the same type (integer or float).
        Requires server version 5.6.0+.
        """
    @staticmethod
    def cond(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Conditionally select an expression from a variable number of expression pairs
        followed by default expression action.
        Requires server version 5.6.0+.
        ```
        // Args Format: bool exp1, action exp1, bool exp2, action exp2, ..., action-default
        // Apply operator based on type.
        """
    @staticmethod
    def exp_let(exps:typing.Sequence[FilterExpression]) -> FilterExpression:
        r"""
        Define variables and expressions in scope.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def def(name:builtins.str, value:FilterExpression) -> FilterExpression:
        r"""
        Assign variable to an expression that can be accessed later.
        Requires server version 5.6.0+.
        ```
        // 5 < a < 10
        """
    @staticmethod
    def var(name:builtins.str) -> FilterExpression:
        r"""
        Retrieve expression value from a variable.
        Requires server version 5.6.0+.
        """
    @staticmethod
    def unknown() -> FilterExpression:
        r"""
        Create unknown value. Used to intentionally fail an expression.
        The failure can be ignored with `ExpWriteFlags` `EVAL_NO_FAIL`
        or `ExpReadFlags` `EVAL_NO_FAIL`.
        Requires server version 5.6.0+.
        """

class GeoJSON:
    @property
    def value(self) -> builtins.str: ...
    @value.setter
    def value(self, value: builtins.str) -> None: ...
    def __new__(cls, v:builtins.str) -> GeoJSON: ...
    def as_string(self) -> builtins.str:
        r"""
        Returns a string representation of the value.
        """
    def __richcmp__(self, other:typing.Any, op:int) -> builtins.bool: ...

class HLL:
    @property
    def value(self) -> builtins.list[builtins.int]: ...
    @value.setter
    def value(self, value: builtins.list[builtins.int]) -> None: ...
    def __new__(cls, v:typing.Sequence[builtins.int]) -> HLL: ...
    def as_string(self) -> builtins.str:
        r"""
        Returns a string representation of the value.
        """
    def __richcmp__(self, other:typing.Any, op:int) -> builtins.bool: ...

class Key:
    @property
    def namespace(self) -> builtins.str: ...
    @property
    def set_name(self) -> builtins.str: ...
    @property
    def value(self) -> typing.Optional[typing.Any]: ...
    @property
    def digest(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, namespace:builtins.str, set:builtins.str, key:typing.Any) -> Key: ...
    def __richcmp__(self, other:Key, op:int) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __copy__(self) -> Key: ...
    def __deepcopy__(self, _memo:dict) -> Key: ...

class List:
    @property
    def value(self) -> builtins.list[typing.Any]: ...
    @value.setter
    def value(self, value: builtins.list[typing.Any]) -> None: ...
    def __new__(cls, v:typing.Sequence[typing.Any]) -> List: ...
    def as_string(self) -> builtins.str:
        r"""
        Returns a string representation of the value.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __getitem__(self, idx:builtins.int) -> typing.Any: ...
    def __setitem__(self, idx:builtins.int, v:typing.Any) -> None: ...
    def __hash__(self) -> builtins.int: ...
    def __richcmp__(self, other:typing.Any, op:int) -> builtins.bool: ...
    def __iter__(self) -> List: ...
    def __next__(self) -> typing.Optional[typing.Any]: ...

class Map:
    @property
    def value(self) -> builtins.dict[typing.Any, typing.Any]: ...
    @value.setter
    def value(self, value: builtins.dict[typing.Any, typing.Any]) -> None: ...
    def __new__(cls, v:typing.Mapping[typing.Any, typing.Any]) -> Map: ...
    def as_string(self) -> builtins.str:
        r"""
        Returns a string representation of the value.
        """
    def __richcmp__(self, other:typing.Any, op:int) -> builtins.bool: ...

class PartitionFilter:
    def __new__(cls) -> PartitionFilter: ...
    def done(self) -> builtins.bool: ...
    @staticmethod
    def all() -> PartitionFilter: ...
    @staticmethod
    def by_id(id:builtins.int) -> PartitionFilter: ...
    @staticmethod
    def by_key(key:Key) -> PartitionFilter: ...
    @staticmethod
    def by_range(begin:builtins.int, count:builtins.int) -> PartitionFilter: ...

class Privilege:
    @property
    def code(self) -> PrivilegeCode: ...
    @property
    def namespace(self) -> typing.Optional[builtins.str]: ...
    @property
    def set_name(self) -> typing.Optional[builtins.str]: ...
    def __new__(cls, code:PrivilegeCode, namespace:typing.Optional[builtins.str], set_name:typing.Optional[builtins.str]) -> Privilege: ...
    def as_string(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class QueryPolicy:
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def fail_on_cluster_change(self) -> builtins.bool: ...
    @fail_on_cluster_change.setter
    def fail_on_cluster_change(self, value: builtins.bool) -> None: ...
    def __new__(cls) -> QueryPolicy: ...

class ReadPolicy(BasePolicy):
    ...

class Record:
    ...

class Recordset:
    r"""
    Virtual collection of records retrieved through queries and scans. During a query/scan,
    multiple threads will retrieve records from the server nodes and put these records on an
    internal queue managed by the recordset. The single user thread consumes these records from the
    queue.
    """
    ...

class ScanPolicy:
    @property
    def max_concurrent_nodes(self) -> builtins.int: ...
    @max_concurrent_nodes.setter
    def max_concurrent_nodes(self, value: builtins.int) -> None: ...
    @property
    def record_queue_size(self) -> builtins.int: ...
    @record_queue_size.setter
    def record_queue_size(self, value: builtins.int) -> None: ...
    @property
    def socket_timeout(self) -> builtins.int: ...
    @socket_timeout.setter
    def socket_timeout(self, value: builtins.int) -> None: ...
    def __new__(cls) -> ScanPolicy: ...

class Statement:
    r"""
    Query statement parameters.
    """
    @property
    def filters(self) -> typing.Optional[builtins.list[Filter]]: ...
    @filters.setter
    def filters(self, value: typing.Optional[builtins.list[Filter]]) -> None: ...
    def __new__(cls, namespace:builtins.str, set_name:builtins.str, bins:typing.Optional[typing.Sequence[builtins.str]]) -> Statement: ...

class WritePolicy:
    @property
    def record_exists_action(self) -> typing.Any: ...
    @record_exists_action.setter
    def record_exists_action(self, value: typing.Any) -> None: ...
    @property
    def generation_policy(self) -> typing.Any: ...
    @generation_policy.setter
    def generation_policy(self, value: typing.Any) -> None: ...
    @property
    def commit_level(self) -> typing.Any: ...
    @commit_level.setter
    def commit_level(self, value: typing.Any) -> None: ...
    @property
    def generation(self) -> builtins.int: ...
    @generation.setter
    def generation(self, value: builtins.int) -> None: ...
    @property
    def expiration(self) -> Expiration: ...
    @expiration.setter
    def expiration(self, value: Expiration) -> None: ...
    @property
    def send_key(self) -> builtins.bool: ...
    @send_key.setter
    def send_key(self, value: builtins.bool) -> None: ...
    @property
    def respond_per_each_op(self) -> builtins.bool: ...
    @respond_per_each_op.setter
    def respond_per_each_op(self, value: builtins.bool) -> None: ...
    @property
    def durable_delete(self) -> builtins.bool: ...
    @durable_delete.setter
    def durable_delete(self, value: builtins.bool) -> None: ...
    def __new__(cls) -> WritePolicy: ...

class CollectionIndexType(Enum):
    r"""
    Secondary index collection type.
    """
    Default = ...
    List = ...
    MapKeys = ...
    MapValues = ...

class IndexType(Enum):
    r"""
    Underlying data type of secondary index.
    """
    Numeric = ...
    String = ...
    Geo2DSphere = ...

class PrivilegeCode(Enum):
    r"""
    Secondary index collection type.
    """
    UserAdmin = ...
    r"""
    User can edit/remove other users.  Global scope only.
    """
    SysAdmin = ...
    r"""
    User can perform systems administration functions on a database that do not involve user
    administration.  Examples include server configuration.
    Global scope only.
    """
    DataAdmin = ...
    r"""
    User can perform UDF and SINDEX administration actions. Global scope only.
    """
    UDFAdmin = ...
    r"""
    User can perform user defined function(UDF) administration actions.
    Examples include create/drop UDF. Global scope only.
    Requires server version 6+
    """
    SIndexAdmin = ...
    r"""
    User can perform secondary index administration actions.
    Examples include create/drop index. Global scope only.
    Requires server version 6+
    """
    Read = ...
    r"""
    User can read data only.
    """
    ReadWrite = ...
    r"""
    User can read and write data.
    """
    ReadWriteUDF = ...
    r"""
    User can read and write data through user defined functions.
    """
    Write = ...
    r"""
    User can read and write data through user defined functions.
    """
    Truncate = ...
    r"""
    User can truncate data only.
    Requires server version 6+
    """

def new_client(policy:ClientPolicy, seeds:builtins.str) -> typing.Awaitable[Client]: ...

